#!/usr/bin/env bash
# shellcheck disable=SC2155

# TODO: what to do about account recovery code?

# shellcheck disable=SC2120
usage() {
    echo
    echo "$(ansi bold Create a backup of a Bitwarden vault or restore a vault from one, secured by an) $(ansi cyan Age) $(ansi bold public key pair.)"
    echo
    echo "Usage: $(ansi bold_blue ${scriptName}) [backup] (-r RECIPIENT | -R PATH)... [-b BACKUP_DIR]"
    echo "       $(ansi bold_blue ${scriptName}) restore BACKUP_FILE -i IDENTITY"
    echo
    echo "The Bitwarden CLI is used to access the vault. Login/unlock requires user input: credentials are never stored."
    echo "Using an API key simplifies login, requiring only master password input rather than full credentials. This is"
    echo "enabled by setting the BW_CLIENTID and BW_CLIENTSECRET environment variables, for details see"
    echo "$(ansi blue https://bitwarden.com/help/personal-api-key/)."
    echo
    echo "Backup files are encrypted with $(ansi cyan Age) public keys â€” see $(ansi blue ${rageProjectUrl}) for details on features"   # TODO: valt keys !!!
    echo "and key creation. In the $(ansi cyan Age) system, a public key is called a 'recipient' and a private key is called an"
    echo "'identity'. Identities/private keys $(ansi bold_italic should) be protected by a strong password for this use case, and a copy"
    echo "of both the key and password should be stored offline in $(ansi italic at least) one secure location."
    echo
    echo "$(ansi bold_green Note) A temporary directory is required during both operations, and $(ansi italic unencrypted) vault data will be stored there."
    echo "These files will be deleted by this script; however, file recovery software may still be able to read them long"
    echo "afterward. Standard security practice is to use encrypted storage to avoid this risk, so by default you will be"
    echo "prompted to agree that the temp directory is secured. If your system uses whole disk encryption, or if the"
    echo "directory specified via -t is known to be encrypted (e.g. by VeraCrypt), this prompt can be suppressed by"
    echo "setting the WARDN_SECURE_TEMP_DIR environment variable (see below)."
    echo
    echo "Options:"
    echo
    echo "    -t, --temp-dir PATH            Use the directory at PATH for temporary storage."
    echo "    -r, --recipient RECIPIENT      Encrypt to the specified RECIPIENT (public key). May be repeated."
    echo "    -R, --recipients-file PATH     Encrypt to the recipients (public keys) listed at PATH. May be repeated."
    echo "    -b, --backup-dir PATH          Use the secure directory at PATH to store the encrypted backup."
    echo "    -p, --prefix PREFIX            Set a prefix for the backup file name."
    echo "    -u, --url URL                  Set the URL for the Bitwarden server. Defaults to ${defaultServerUrl}"
    echo "    -i, --identity IDENTITY        Restore using the identity (private key) file at IDENTITY. May be repeated."
    echo "    -l, --login                    Force full login even if API key environment variables are set."
    echo "    -h, --help                     Print this help message and exit."
    echo "    -v                             Print the version and exit."
    echo "    --version                      Print the version with release date and exit."
    echo
    echo "Environment Variables"
    echo
    echo "    BW_CLIENTID                    Set the Bitwarden API key."
    echo "    BW_CLIENTSECRET                Set the Bitwarden API key secret."
    echo "    WARDN_BACKUP_DIR               Set the default backup destination directory."
    echo "    WARDN_BACKUP_PREFIX            Set default backup file name prefix."
    echo "    WARDN_RECIPIENT                Set default recipient. May be a path to a recipients file."
    echo "    WARDN_IDENTITY                 Set default identity file."
    echo "    WARDN_SECURE_TEMP_DIR          Set the default secure temp directory. Use '@' to create a path via $(ansi italic mktemp)."
    echo "    WARDN_PASSWORD_VISIBILITY      Set the visibility of password entry characters: none, hide, show. Default: none"
    bye "${@}"
}

main() {
    init "${@}"
    prepareVault
    if [[ ${restoreFile} ]]; then
        restoreVault
    else
        backupVault
    fi
}

init() {
    allNewFilesUserOnly
    useValtPinEntry
    readonly scriptName="$(basename "${0}")"
    readonly rageProjectUrl='https://github.com/str4d/rage'
    readonly defaultServerUrl='https://vault.bitwarden.com'
    readonly backupFileSuffix='valt'
    readonly vaultFileName='vault.json'
    readonly importVaultFileName='import-vault.json'
    readonly attachmentsDirName='attachments'
    readonly restoreNoteName='ðŸ”¥ Restored Vault'
    readonly doneCheck=". ${_greenCheckMark}"
    declare -grx passwordVisibility="${WARDN_PASSWORD_VISIBILITY:-none}"
    declare -g bwPath
    bwPath=${ which bw; }

    namePrefix="${WARDN_BACKUP_PREFIX}"
    vaultUrl=
    backupFile=
    restoreFile=

    suppliedTempDir="${WARDN_SECURE_TEMP_DIR}"
    [[ ${suppliedTempDir} && ${suppliedTempDir} != @ ]] && setDirVar suppliedTempDir "${suppliedTempDir}"

    recipients="${WARDN_RECIPIENT}"
    if [[ ${recipients} ]]; then
        if [[ -f ${recipients} ]]; then
            recipients="-R ${recipients}"
        else
            recipients="-r ${recipients}"
        fi
    fi

    identities="${WARDN_IDENTITY}"
    if [[ ${identities} ]]; then
        assertFile "${identities}"
    fi

    while (( ${#} > 0 )); do
        case "${1}" in
        backup) unset restoreFile ;;
        restore) shift; setFileVar restoreFile "${1}" ;;
        -t | --temp-dir) shift; setDirVar suppliedTempDir "${1}" "secure temp dir path" ;;
        -r | --recipient) shift; appendVar recipients "-r ${1}" ;;
        -R | --recipients-file) shift; assertFile "${1}" "recipients file"; appendVar recipients "-R ${1}" ;;
        -i | --identity) shift; assertFile "${1}" "identities file"; appendVar identities "-i ${1}" ;;
        -b | --backup-dir) shift; setDirVar backupDir "${1}" "backup dir path" ;;
        -p | --prefix) shift; namePrefix="${1}" ;;
        -u | --url) shift; vaultUrl="${1}" ;;
        -l | --login) unset BW_CLIENTID BW_CLIENTSECRET BW_SESSION WARDN_DEV_BW_PWD ;;
        --update) updateCLI; exit 0 ;;
        --debug) setDebug showOnExit ;;
        --debug-new) setDebug clearLog showOnExit ;;
        --debug-out) setDebug tty "${terminal}" ;;
        --debug-tty) shift; setDebug tty "${1}" ;;
        -h | --help) usage ;;
        -v) projectVersion wardn; exit 0 ;;
        --version) projectVersion wardn true; exit 0 ;;
        *) usage "Unknown argument: ${1}" ;;
        esac
        shift
    done

    if [[ ! ${backupDir} ]]; then
        if [[ ${WARDN_BACKUP_DIR} ]]; then
             setDirVar backupDir "${WARDN_BACKUP_DIR}"
        else
            usage "Secure backup directory not specified."
        fi
    fi

    [[ ${vaultUrl} ]] || vaultUrl="${defaultServerUrl}"

    if [[ ! ${restoreFile} ]]; then

        # backup

        [[ ${recipients} ]] || usage "one or more recipients required"
        [[ ${namePrefix} ]] || namePrefix="${USER}"
        readonly backupName="${namePrefix}-backup-$(timeStamp)"

        if [[ ${backupDir} ]]; then
            backupFile="${backupDir}/${backupName}.${backupFileSuffix}"
        else
            backupFile="${backupName}.${backupFileSuffix}"
        fi
    else

        # restore

        [[ ${identities} ]] || fail "one or more identities required"
        readonly backupName="$(basename ${restoreFile} | cut -d'.' -f1-3)"
    fi

    addExitHandler cleanup

    initSecureTempDir
    readonly secureWorkDir="$(makeDir "${secureTempDir}" "${backupName}")"
    readonly vaultFile="${secureWorkDir}/vault.json"
    readonly attachmentsDir="$(makeDir ${secureWorkDir} attachments)"
}

initSecureTempDir() {
    if [[ ${suppliedTempDir} == '' || ${suppliedTempDir} == '@' ]]; then

        # Use the rayvn system temp dir which will be deleted by rayvn on exit

        secureTempDir="$(tempDirPath)"

    else

        # User supplied, so generate a temp dir within it. Remember the generated dir
        # to ensure we delete it on exit

        local randomDirName="$(basename "$(mktemp -d -u)")" || fail
        suppliedTempDir="${suppliedTempDir}"
        generatedTempDir="$(makeDir ${suppliedTempDir} ${randomDirName})"
        secureTempDir=${generatedTempDir}
    fi
    [[ -d ${secureTempDir} ]] || fail "Secure temp directory ${secureTempDir} not found!"
    cd "${secureTempDir}" || fail
    if ! isEncryptedVolume "${secureTempDir}"; then
        verifySecureTempDir
    fi
}

verifySecureTempDir() {
    local source reply
    require 'rayvn/prompt'
    [[ ${generatedTempDir} ]] && source="supplied '${suppliedTempDir}' as root of" || source="system"
    echo
    echo "$(ansi bold Verify configuration)"
    echo
    echo "Using ${source} temp directory: $(ansi blue ${secureTempDir})"
    echo
    prompt "This directory SHOULD be encrypted to avoid leaking sensitive data. $(ansi bold_green Proceed?)" yes no reply
    if [[ ${reply} != 'yes' ]]; then
        echo
        fail "See help for more about this issue: ${scriptName} --help"
    fi
}

isEncryptedVolume() {
    local dirPath="${1}"
    local mountPoint
    local device
    if (( onMacOS )); then

        # Resolve the mount point of the directory
        mountPoint="$(df -P "${dirPath}" | tail -1 | awk '{print $6}')" || return 1

        # Get the device associated with the mount point
        device="$(df -P "${dirPath}" | tail -1 | awk '{print $1}')" || return 1

        # Check if the device is listed as encrypted
        diskutil info "${device}" | grep -q "^ *FileVault: *Yes"
    fi
}

prepareVault() {
    echo
    if [[ ${restoreFile} ]]; then
        echo "$(ansi bold Restore Backup)"
    else
        echo "$(ansi bold Create Backup)"
    fi
    echo
    debugStatus
    if ! useParentSession; then
        ensureLatestCLI
        unlockVault
    fi
    syncVault
}

useParentSession() {
    if [[ ${WARDN_USE_PARENT_SESSION} && ${BW_SESSION} ]]; then
        if [[ $(sessionStatus) == unlocked ]]; then
            echo "Skipping login, parent session appears valid${doneCheck}"
            return 0
        fi
    fi
    return 1
}

ensureLatestCLI() {
    startSpinner "Checking Bitwarden CLI version"

    # The bw update command may say there is a new version, but it is possible for the brew formula
    # to be stuck at an older one (e.g. build failures). Since we rely on brew, check

    if HOMEBREW_NO_AUTO_UPDATE= brew upgrade --dry-run bitwarden-cli 2>&1 | grep -q "already installed"; then
        stopSpinner ": $(ansi blue "${bwPath}") is up to date (via brew) at $(bw --version)${doneCheck}"
    else
        stopSpinner ": $(ansi bold_red "${bwPath}" is out of date.)"
        echo
        echo "Try executing: HOMEBREW_NO_AUTO_UPDATE= brew upgrade bitwarden-cli"
        bye
    fi
}

sessionStatus() {
    bw status | jq -r '.status'
}

unlockVault() {
    startSpinner "Unlocking vault"

    logoutFromVault force # just in case there is an active session
    declare -gx BW_SESSION

    bw config server "${vaultUrl}" &> /dev/null

    if [[ ${BW_CLIENTID} ]]; then

        # Use api key to login

        bw login --apikey > /dev/null || failSpin "login with api key failed"

        # Unlock vault

        openVault unlock

    else

        # Login and unlock without api key

        openVault login
    fi

    [[ ${BW_SESSION} ]] || failSpin "unlock failed"
}

openVault() {
    local command=${1}
    if [[ ${WARDN_DEV_BW_PWD} ]]; then
        useDevPassword ${command}
    else
        useCredentials ${command}
    fi
}

useDevPassword() {
    local command=${1}
    debug "useDevPassword ${command}"
    [[ ${command} == login ]] && stopSpinner ". Credentials required..."
    BW_SESSION="$(bw ${command} --raw --passwordenv WARDN_DEV_BW_PWD)"
    [[ ${command} == unlock ]] && stopSpinner "${doneCheck}"
}

useCredentials() {
    local command=${1}
    stopSpinner ". Credentials required..."
    debug "useCredentials ${command}"
    for retryIndex in {1..3}; do
        BW_SESSION="$(bw ${command} --raw)" && break
    done
}

syncVault() {
    startSpinner "Syncing vault"
    bw sync > /dev/null || fail
    stopSpinner "${doneCheck}"
}

backupVault() {
    local items item
    local attachmentItemIds attachmentItemId
    local attachments attachment
    local attachDir
    local itemsCount
    local attachmentsCount

    startSpinner "Backing up vault"

    bw export --raw --format json > "${vaultFile}" || failSpin
    items="$(bw list items)"
    itemsCount=$(echo "${items}" | jq 'length')

    attachmentItemIds="$(echo ${items} | jq -r ".[] | select(.attachments).id")"

    for attachmentItemId in ${attachmentItemIds}; do
        item="$(echo "${items}" | jq -r ".[] | select(.id == \"${attachmentItemId}\")")"
        attachments="$(echo "${item}" | jq -r ".attachments")"
        length="$(echo "${attachments}" | jq -r ". | length")"

        for ((retryIndex = 0; retryIndex < ${length}; retryIndex++)); do
            attachDir="$(makeDir ${attachmentsDir} ${attachmentItemId})"

            attachment="$(echo "${attachments}" | jq ".[${retryIndex}]")"
            attachmentId="$(echo "${attachment}" | jq -r ".id")"
            fileName="$(echo "${attachment}" | jq -r ".fileName")"

            # get attachment

            bw get attachment "${attachmentId}" --itemid "${attachmentItemId}" \
                --output "${attachDir}/${fileName}" >/dev/null 2>&1 || failSpin

            (( attachmentsCount++ ))
        done
    done
pwd # HERE what is wrong with the tar command below? It fails with tar: test-backup-2025-07-31_12.45.05_PDT: Cannot stat: No such file or directory
declare -p backupName vaultFile

    tar cz "${backupName}" | rage ${recipients} > ${backupFile} || failSpin
    local size="$(du -h "${backupFile}" | cut -d' ' -f2 | cut -d $'\t' -f1)"

    stopSpinner "${doneCheck}"

    if (( attachmentsCount > 0 )); then
        echo "Backed up ${itemsCount} items and ${attachmentsCount} attachments. ${_greenCheckMark}"
    else
        echo "Backed up ${itemsCount} items. ${_greenCheckMark}"
    fi
    logoutFromVault
    echo
    echo "$(ansi bold_green Vault backed up to) ${backupFile} $(ansi bold_green size): $(ansi bold ${size})"
}

restoreVault() {

    # There are two issues with restoring a vault that make this implementation far more complicated
    # than expected/desirable:
    #
    #  1. Importing a vault REPLACES the item ids and creation/revision dates with NEW ones, therefore
    #  2. Restoring attachments requires MAPPING the old ids (from the backup) to the NEW ones.
    #
    # A reasonable case can be made that issue #1 is a bug. If fixed, BOTH issues go away.
    #
    # Since we MUST restore attachments, and we SHOULD use the original dates, we workaround these issues
    # using this high level approach:
    #
    #    import the backup -> export the result -> edit each item -> upload attachments
    #
    # Restore Procedure
    #
    #  0. ensure target vault is EMPTY
    #  1. unlock/unpack backup to temp dir
    #  2. load vault.json into ${oldVault}
    #  3. extract stats from ${oldVault}
    #  4. for each item in ${oldVault}, modify name with its index number. Used to map item ids independent of export order.
    #  5. create an oldIds array by extraction from ${oldVault}
    #  6. import ${oldVault} to target.
    #  7. export target vault to ${newVault}
    #  8. for each item in ${oldVault}, set oldId from oldIds(${i}) and:
    #       a. set oldId from ${oldIds} using loop index
    #       a. extract newItem from ${newVault} using loop index
    #       b. extract newId from ${newItem}
    #       c. update ${idMap} with ${oldId} -> ${newId} for attachment processing
    #       b. edit item ${newId} and update it with:
    #           1. name stripped of index prefix
    #           2. creation date from old item
    #           3. revision date from old item
    #           4. deleted date from old item
    #  9. create note item in target with stats
    # 10. restore attachments using ${idMap}
    #
    # NOTE: At present, an edit with any of the original dates fails; an issue has been created
    # (https://github.com/bitwarden/clients/issues/13429) and the code is commented until a fix is implemented.

    local backupFile="${restoreFile}"
    local backupFileName="$(basename ${backupFile})"
    local oldIds=()
    declare -A idMap=()

    assertVaultReady  # (STEP 0)

    # Extract contents of decrypted backup file to secureWorkDir (STEP 1)

    echo "Preparing backup. You will be prompted for your private key passphrase if encrypted."
    cd "${secureWorkDir}" || fail
    local tarFile="backup.tar"
    rage -d ${identities} "${backupFile}" -o "${tarFile}" 2> >(redStream) || fail

    startSpinner "Preparing import" # don't start until here, since the above will likely prompt for a password
    tar -xf "${tarFile}" --strip-components=1 || fail
    rm "${tarFile}" || fail

    # Get vault and grab some stats from it (STEPS 2 & 3)

    local oldVault="$(cat "${vaultFileName}")"
    local itemsCount=$(echo "${oldVault}" | jq '.items // 0 | length')
    local foldersCount=$(echo "${oldVault}" | jq '.folders // 0 | length')
    local attachmentsCount="$(find attachments -type f | wc -l | awk '{print $1}')"

    # Update the names with sequence number prefixes so we can correctly map them later (STEP 4)

    debugJson oldVault 'before'
    prefixNamesWithIndex oldVault ${itemsCount}
    debugJson oldVault 'after'

    # Extract old item ids (STEP 5)

    mapfile -t oldIds < <(echo "${oldVault}" | jq -r '.items[].id')

    # Import updated vault (STEP 6)

    restartSpinner "${doneCheck}" "Importing vault"
    echo "${oldVault}" > "${importVaultFileName}"
    bw import bitwardenjson "./${importVaultFileName}" > /dev/null || fail

    # Export vault (STEP 7)

    local newVault="$(bw export --format json --raw)" || fail

    # Edit each item in the new vault to fix name and copy old dates, building idMap (STEP 8)

    local suffix="$( (( itemsCount < 10 )) && echo '' || echo ' (this may take some time)')"
    restartSpinner "${doneCheck}" "Restoring ${itemsCount} items${suffix}"
    restoreItems oldVault newVault oldIds idMap ${itemsCount}

    # Add a note (STEP 9)

    addNote "${backupFile}" ${itemsCount} ${foldersCount} ${attachmentsCount}

    # Process attachments if we have any (STEP 10)

    if (( ${attachmentsCount} > 0 )); then
        restartSpinner "${doneCheck}" "Uploading ${attachmentsCount} attachments"
        uploadAttachments idMap
    fi

    stopSpinner "${doneCheck}"

    logoutFromVault

    echo
    echo "$(ansi bold_green Restore completed.)"
    echo
    echo "A note named '${restoreNoteName}' was added to your vault with details of this operation."
    echo
    suffix="$( (( attachmentsCount > 0 )) && echo ' and attachments.' || echo '.')"
    echo "You will likely need to logout/login to see all restored items${suffix}"
}

prefixNamesWithIndex() {   # STEP 4
    local -n vaultRef=${1}
    local itemsCount=${2}
    local key newName
    local tempVault="${vaultRef}" # TODO don't need this indirection

    for ((i = 0; i < itemsCount; i++)); do
        name=$(echo "${tempVault}" | jq -r --argjson i ${i} '.items[$i].name')
        newName="<${i}> ${name}"
        tempVault=$(echo "${tempVault}" | jq --argjson i ${i} --arg name "${newName}" '.items[$i].name=$name')
    done
    vaultRef="${tempVault}"
}

restoreItems() { # STEP 8

    local -n oldVaultRef=${1}
    local -n newVaultRef=${2}
    local -n oldIdsRef=${3}
    local -n idMapRef=${4}
    local itemsCount=${5}
    local i oldId newId newItem indexedName key newItem restoredItem editedItem # cDate rDate dDate

    for (( i = 0; i < itemsCount; i++ )); do

        # Get the oldId and oldItem

        oldId=${oldIdsRef[${i}]}
        oldItem=$(echo ${oldVaultRef} | jq -r --arg id "${oldId}" '.items[] | select(.id == $id)')

        # Lookup the newItem by index and extract newId

        newItem=$(echo "${newVaultRef}" | jq -r --arg index ${i} '.items[] | select(.name | startswith("<" + ($index|tostring) + ">"))')
        newId=$(echo "${newItem}" | jq -r '.id')

        # Update the idMap for attachment processing

        idMapRef["${oldId}"]="${newId}"

        # Get the item name without the index prefix

        indexedName=$(echo ${newItem} | jq -r '.name')
        name="${indexedName#\<[0-9]*\> }"

        debug ''; debugVar i oldId newId indexedName name

        # Update newItem

# TODO See https://github.com/bitwarden/clients/issues/13429
#
#        cDate=$(echo ${oldItem} | jq -r '.creationDate')
#        rDate=$(echo ${oldItem} | jq -r '.revisionDate')
#        dDate=$(echo ${oldItem} | jq -r '.deletedDate')
#
#        restoredItem=$(echo "${newItem}" | jq -c --arg name "${name}" --arg id "${newId}" --arg c "${cDate}" --arg r "${rDate}" --arg d "${dDate}" \
#            '.name=$name | .id=$id | .creationDate=$c | .revisionDate=$r | .deletedDate=$d' )

        restoredItem=$(echo "${newItem}" | jq -c --arg name "${name}"  --arg id "${newId}" '.name=$name | .id=$id')
        debugJson restoredItem "restoredItem-${i}"

        # Finally, edit the item in the vault to restore it

        editedItem=$(echo "${restoredItem}" | bw encode | bw edit item "${newId}")
        debugJson editedItem "editedItem-${i}"

    done
}

addNote() {  # STEP 9
    local source="${1}"
    local items=${2}
    local folders=${3}
    local attachments=${4}
    local i=$( [[ ${items} == 1 ]] && echo item || echo items)
    local f=$( [[ ${folders} == 1 ]] && echo folder || echo folders)
    local a=$( [[ ${items} == 1 ]] && echo attachment || echo attachments)
    local format='Restored on %s\n\n%d %s, %d %s, %d %s from %s\n'
    note="$(printf "${format}" "$(date)" ${items} ${i} ${folders} ${f} ${attachments} ${a} "${source}")"

    # TODO Add hostname, username, uname, IP, reverse dns... https://iplocation.io/ ip.info ???

    debugJson note

    local temp=$(bw get template item) || fail
    local key="${restoreNoteName}"
    local item=$(echo ${temp} | jq -r --arg nm "${name}" --arg nt "${note}" '.type=2 | .secureNote.type=0 | .name=$nm | .notes=$nt')
    echo ${item} | bw encode | bw create item > /dev/null || fail
}

uploadAttachments() { # STEP 10
    local -n idMapRef=${1}
    local attachmentDir attachmentFile
    pushd "${attachmentsDirName}" > /dev/null || fail

    for attachmentDir in ./*; do

        pushd "${attachmentDir}" > /dev/null || fail
        local oldAttachmentItemId="$(basename ${attachmentDir})"
        local newAttachmentItemId="${idMapRef[${oldAttachmentItemId}]}"
        debugVar oldAttachmentItemId newAttachmentItemId

        for attachmentFile in ./*; do
            debugVar attachmentFile
            bw create attachment --file "./${attachmentFile}" --itemid "${newAttachmentItemId}" > /dev/null || fail
        done
        popd > /dev/null || fail
    done
}

assertVaultReady() {
    startSpinner "Checking vault"

    local vault="$(bw export --raw --format json)"

    local orgVault="$(echo "${vault}" | jq '.collections != null' | grep true)"
    [[ ${orgVault} ]] && failSpin "Cannot restore to an Organization vault (yet)."

    local itemsCount=$(echo "${vault}" | jq '.items // 0 | length')
    (( itemsCount == 0 )) || failVaultNotEmpty

    local foldersCount=$(echo "${vault}" | jq '.folders // 0 | length')
    (( foldersCount == 0 )) || failVaultNotEmpty
    stopSpinner "${doneCheck}"
}

failVaultNotEmpty() {
    stopSpinner ": $(ansi red vault must be empty before restoring to it.)"
    echo
    echo "If you are not $(ansi bold_italic sure) that you have a current backup, make another one or restore"
    echo "to a new account (with a Premium subscription if you have attachments)."
    echo
    echo "If you choose to empty the target vault:"
    echo
    echo "  1. In a browser, login at $(ansi blue ${vaultUrl})."
    echo "  2. In the left pane, under $(ansi bold Settings), click $(ansi bold My Account)."
    echo "  3. In the $(ansi red Danger zone) section, click $(ansi red Purge vault)."
    echo "  4. In the popup, enter you master password and click $(ansi red Purge vault)."
    fail
}

logoutFromVault() {
    local arg=${1}
    if [[ ${arg} == force ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    elif [[ ${BW_SESSION} && ! ${WARDN_USE_PARENT_SESSION} ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    fi
}

cleanup() {
    logoutFromVault

    [[ ${debug} ]] && exec 3<&- # close file descriptor

    if [[ ${generatedTempDir} ]]; then
        rm -rf "${generatedTempDir}" > /dev/null 2>&1 || warn "Failed to delete temp dir: ${generatedTempDir}"
    fi
}

updateCLI () { # TODO: harden and expose command!
#    local url="${1}"
    local installFile="$(command -v bw)"
    local installDir="$(dirname ${installFile})"
    echo "Installed version: $(${installFile} --version)"
    if [[ ! ${url} ]]; then
        local response="$(bw update | grep http)"
        if [[ ${response} ]]; then
            url="http${response##*http}"
        fi
    fi
    if [[ "${url}" ]]; then
        local tempFile="${installFile}.zip"
        curl "${url}" -L -o "${tempFile}" 2> /dev/null || return
        rm "${installFile}" 2>&1 > /dev/null
        unzip -q -u "${tempFile}" -d "${installDir}"
        rm "${tempFile}" || return
        chmod +x "${installFile}" || return
        echo "       Updated to: $(${installFile} --version)"
    else
        echo "No update available."
    fi
}

# Boot rayvn with initial required libraries

source rayvn.up --add 'wardn,valt' 'rayvn/spinner' 'rayvn/debug' 'valt/pinentry'

main "${@}"
