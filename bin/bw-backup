#!/usr/bin/env bash

declare -grx BW_BACKUP_VERSION='bw-backup 0.1.0'

# TODO: what to do about account recovery code?

# shellcheck disable=SC2120
usage() {
    echo
    echo "$(ansi bold Create a backup of a Bitwarden vault or restore a vault from one, secured by an) $(ansi cyan Age) $(ansi bold public key pair.)"
    echo
    echo "Usage: $(ansi bold_blue ${scriptName}) [--create] (-r RECIPIENT | -R PATH)... [-b BACKUP_DIR]"
    echo "       $(ansi bold_blue ${scriptName}) --restore BACKUP_FILE -i IDENTITY"
    echo
    echo "The Bitwarden CLI is used and an API key and secret is required, both of which must be set in the environment"
    echo "variables BW_CLIENTID and BW_CLIENTSECRET respectively. See $(ansi blue https://bitwarden.com/help/personal-api-key/)."
    echo
    echo "Backup files are encrypted with $(ansi cyan Age) public keys â€” see $(ansi blue ${rageProjectUrl}) for details on features"
    echo "and key creation. In the $(ansi cyan Age) system, a public key is called a 'recipient' and a private key is called an"
    echo "'identity'. Identities/private keys $(ansi bold_italic SHOULD) be protected by a strong password for this use case, and a copy"
    echo "of both the key and password should be stored offline in $(ansi italic at least) one secure location."
    echo
    echo "$(ansi bold_green Note) A temporary directory is required during both operations, and $(ansi italic unencrypted) vault data will be stored there."
    echo "These files will be deleted by this script; however, file recovery software may still be able to read them long"
    echo "afterward. Standard security practice is to use encrypted storage to avoid this risk, so by default you will be"
    echo "prompted to agree that the temp directory is secured. If your system uses whole disk encryption, or if the"
    echo "directory specified via -t is known to be encrypted (e.g. by VeraCrypt), this prompt can be suppressed by"
    echo "setting the BW_BACKUP_TEMP_DIRECTORY environment variable (see below)."
    echo
    echo "Options:"
    echo
    echo "    -t, --temp-dir PATH            Use the directory at PATH for temporary storage."
    echo "    -r, --recipient RECIPIENT      Encrypt to the specified RECIPIENT (public key). May be repeated."
    echo "    -R, --recipients-file PATH     Encrypt to the recipients (public keys) listed at PATH. May be repeated."
    echo "    -b, --backup-dir PATH          Use the directory at PATH to store the encrypted backup."
    echo "    -p, --prefix PREFIX            Set a prefix for the backup file name."
    echo "    -u, --url URL                  Set the URL for the Bitwarden server. Defaults to ${defaultServerUrl}"
    echo "    --restore PATH                 Restore using the backup file at PATH."
    echo "    -i, --identity IDENTITY        Restore using the identity (private key) file at IDENTITY. May be repeated."
    echo "    -h, --help                     Display usage and exit."
    echo "    --version                      Display version and exit."
    echo
    echo "Environment Variables"
    echo
    echo "    BW_CLIENTID                    Set the Bitwarden API key (REQUIRED)."
    echo "    BW_CLIENTSECRET                Set the Bitwarden API key secret (REQUIRED)."
    echo "    BW_BACKUP_PREFIX               Set default backup name prefix."
    echo "    BW_BACKUP_RECIPIENT            Set default recipient. May be a path to a recipients file."
    echo "    BW_BACKUP_DIR                  Set the default backup directory."
    echo "    BW_BACKUP_SECURE_TEMP_DIR      Set the default secure temp directory. Use '@' to create a path via $(ansi italic mktemp)."
    bye "${@}"
}

main() {
    assertExecutables requiredExecutables
    init "${@}"
    ensureLatestCLI
    loginToVault
    syncVault
    if [[ ${restoreFile} ]]; then
        restoreVault
    else
        backupVault
    fi
    logoutFromVault verbose
}

init() {
    [[ ${BW_CLIENTID} ]] || fail "BW_CLIENTID env var not set"
    [[ ${BW_CLIENTSECRET} ]] || fail "BW_CLIENTSECRET env var not set"
    readonly scriptName="$(basename "${0}")"
    declare -grx PINENTRY_PROGRAM="${RAYVN_BIN_DIR}/rayvn-pinentry"
    readonly rageProjectUrl='https://github.com/str4d/rage'
    readonly defaultServerUrl="https://vault.bitwarden.com"
    namePrefix="${BW_BACKUP_PREFIX}"
    vaultUrl=
    identities=
    restoreFile=
    suppliedTempDir="${BW_BACKUP_SECURE_TEMP_DIR}"
    backupDir="${BW_BACKUP_DIR}"
    recipients="${BW_BACKUP_RECIPIENT}"

    [[ ${suppliedTempDir} && ${suppliedTempDir} != @ ]] && setDirVar suppliedTempDir "${suppliedTempDir}"
    [[ ${backupDir} ]] && setDirVar backupDir "${backupDir}"
    [[ ${recipients} && -f ${recipients} ]] && recipients="-R ${recipients}" || recipients="-r ${recipients}"

# echo "-- BEGIN init ----------"; printVar suppliedTempDir recipients backupDir backupFile generatedTempDir # TODO REMOVE

    while ((${#} > 0)); do
        case "${1}" in
        --create) unset restoreFile ;;
        --restore) shift; setFileVar restoreFile "${1}" ;;
        -t | --temp-dir) shift; setDirVar suppliedTempDir "${1}" "secure temp dir path" ;;
        -r | --recipient) shift; appendVar recipients "-r ${1}" ;;
        -R | --recipients-file) shift; assertFile "${1}" "recipients file"; appendVar recipients "-R ${1}" ;;
        -i | --identity) shift; assertFile "${1}" "identities file"; appendVar identities "-i ${1}" ;;
        -b | --backup-dir) shift; setDirVar backupDir "${1}" "backup dir path" ;;
        -p | --prefix) shift; namePrefix="${1}" ;;
        -u | --url) shift; vaultUrl="${1}" ;;
        -h | --help) usage ;;
        -v | --version) version "${BW_BACKUP_VERSION}" ;;
        *) setPrefix "${1}" ;;
        esac
        shift
    done

    if [[ ${restoreFile} ]]; then
        [[ ${identities} ]] || fail "one or more identities required"
    else
        [[ ${recipients} ]] || fail "one or more recipients required"
    fi

    [[ ${namePrefix} ]] || namePrefix="${USER}"
    [[ ${vaultUrl} ]] || vaultUrl="${defaultServerUrl}"
    readonly backupName="${namePrefix}-backup-$(timeStamp)"

    if [[ ${backupDir} ]]; then
        backupFile="${backupDir}/${backupName}.tar.gz.age"
    else
        backupFile="${backupName}.tar.gz.age"
    fi

    addExitHandler cleanup

    initSecureTempDir
    readonly vaultFile="${tempDir}/vault.json"
    readonly attachmentsDir="$(makeDir ${tempDir} attachments)"

# echo "-- END init ----------"; printVar suppliedTempDir secureTempDir recipients backupDir backupFile generatedTempDir; bye # TODO REMOVE
}

initSecureTempDir() {
    local verifySecure
    if [[ ${suppliedTempDir} == '' || ${suppliedTempDir} == '@' ]]; then

        # Use the rayvn system temp dir which will be deleted by rayvn on exit

        secureTempDir="$(tempDirPath)"

    else

        # User supplied, so generate a temp dir within it. Remember the generated dir
        # to ensure we delete it on exit

        local randomDirName="$(basename "$(mktemp -d -u)")" || fail
        suppliedTempDir="${suppliedTempDir}"
        generatedTempDir="$(makeDir ${suppliedTempDir} ${randomDirName})"
        secureTempDir=${generatedTempDir}
        verifySecure=true
    fi
    [[ -d ${secureTempDir} ]] || fail "Secure temp directory ${secureTempDir} not found!"
    cd "${secureTempDir}" || fail
    readonly tempDir="$(makeDir "${secureTempDir}" "${backupName}")"
    chmod 700 "${tempDir}" || fail
    [[ ${verifySecure} ]] && verifySecureTempDir
}

verifySecureTempDir() {
    local source
    local reply
    [[ ${generatedTempDir} ]] && source="supplied '${suppliedTempDir}' as root of" || source="system"
    echo
    echo "$(ansi bold Verify configuration)"
    echo
    echo "Using ${source} temp directory: $(ansi blue ${secureTempDir})"
    echo
    read -t 30 -p "This directory SHOULD be encrypted to avoid leaking sensitive data. $(ansi bold_green Proceed?) [yes/no]: " reply
    if [[ ${reply,,} != 'yes' ]]; then
        echo
        fail "See help for more about this issue: ${scriptName} --help"
    fi
}

ensureLatestCLI() {
    echo
    echo "$(ansi bold_blue Checking Bitwarden CLI version)"
    echo
    local update="$(bw update 2>&1)"
    if [[ ${update} =~ "new version" ]]; then
        printRed "The Bitwarden CLI at $(which bw) is out of date."
        echo
        echo "${update}"
        fail
    fi
    echo "Up to date. Using CLI at $(ansi bold_green "$(which bw)")"
}

loginToVault() {
    session=

    echo
    echo "$(ansi bold_blue Logging in to vault)"
    echo
    startBackgroundSpinner

    logoutFromVault force # just in case there is an active session
    bw config server "${vaultUrl}" > /dev/null
    bw login --apikey > /dev/null || fail "login failed"

    if [[ ${BW_BACKUP_DEV_PWD} ]]; then
        session="$(bw unlock --raw --passwordenv BW_BACKUP_DEV_PWD)"
    else
        for i in {1..3}; do
            echo
            session="$(bw unlock --raw)" && break
        done
    fi
    stopBackgroundSpinner true
    [[ ${session} ]] || fail "login failed"

    echo "$(ansi bold_green Logged in.)"
}

syncVault() {
    echo
    echo "$(ansi bold_blue Syncing vault)"
    echo
    bw sync || fail
}

backupVault() {
    local items item
    local attachmentItemIds attachmentItemId
    local attachments attachment
    local attachDir
    echo
    echo "$(ansi bold_blue Backing up vault)  "
    echo
    #echo -n "$(ansi italic working) "
    startBackgroundSpinner

    bw export --raw --format json --session "${session}" >"${vaultFile}" || failSpin

    items="$(bw list items --session "${session}")"

    attachmentItemIds="$(echo ${items} | jq -r ".[] | select(.attachments).id")"

    for attachmentItemId in ${attachmentItemIds}; do
        item="$(echo "${items}" | jq -r ".[] | select(.id == \"${attachmentItemId}\")")"
        attachments="$(echo "${item}" | jq -r ".attachments")"
        length="$(echo "${attachments}" | jq -r ". | length")"

        for ((i = 0; i < ${length}; i++)); do
            attachDir="$(makeDir ${attachmentsDir} ${attachmentItemId})"

            attachment="$(echo "${attachments}" | jq ".[${i}]")"
            attachmentId="$(echo "${attachment}" | jq -r ".id")"
            fileName="$(echo "${attachment}" | jq -r ".fileName")"

            # get attachment

            bw get attachment "${attachmentId}" --itemid "${attachmentItemId}" --session="${session}" \
                --output "${attachDir}/${fileName}" >/dev/null 2>&1 || failSpin
        done
    done

    tar cz "${backupName}" | rage ${recipients} > ${backupFile} || failSpin
    local size="$(du -h "${backupFile}" | cut -d' ' -f2 | cut -d $'\t' -f1)"

    stopBackgroundSpinner true
    echo "Vault backed up to $(ansi bold_green ${backupFile}) size: $(ansi bold ${size})"
}

restoreVault() {
    local backupFile="${restoreFile}"
    local backupFileName="$(basename ${backupFile})"
    local backupDate="${backupFileName##*backup-}"
    backupDate="$(basename ${backupDate} .tar.gz.age)"

    echo
    echo "$(ansi bold Restoring) $(ansi bold_green ${backupFileName})"
    echo

    # Create new folder

    local restoreFolder="Restore_${backupDate}"
    local encodedFolder="$(bw get template folder --session "${session}" | jq ".name=\""${restoreFolder}"\"" | bw encode)"
    #local encodedFolder="$(bw get template folder --session "${session}" | jq ".name=\""${restoreFolder}"\"" | bw encode)"
    #bw get template folder --session "${session}" "${encodedFolder}"
    local folderId="$(bw create folder "${encodedFolder}" --session "${session}" | jq -r ".id")"

    echo "${restoreFolder} id: ${folderId}"
}


    # On import:
    #
    # 1. imported items are DUPLICATED, with new IDs
    # 2. imported folders with same id are NOT DUPLICATED
    # 3. Deleting a folder (on UI) automatically just moves items tagged in that folder OUt of it.
    #
    # Therefore, to avoid confusion
    # TODO: create new "restore-{DATE} folder" and import into that!
    # Creating a folder requires creating an "encoded" json, e.g.
    #
    # $ bw create folder eyJuYW1lIjoiTXkgRm9sZGVyIn0K
    # {"object":"folder","id":"c7cf9476-d0c8-4281-9832-b26b013c4ead","name":"My Folder"}
    #
    # Use the 'bw encode' command to encode, after using 'bw get template folder'
    # $ bw get template folder | jq '.name="Restore: Jan 20, 2025 11:23am"' | bw encode | bw create folder
    # {"object":"folder","id":"0b0cb093-500c-4b37-9067-b26b013fb31a","name":"Restore: Jan 20, 2025 11:23am"}




logoutFromVault() {
    if [[ ${1} == force ]]; then
        bw logout > /dev/null 2>&1
    elif [[ ${session} ]]; then
        unset session
        if [[ ${1} == verbose ]]; then
            echo
            echo "$(ansi bold_blue Logging out of vault)  "
            echo
            bw logout > /dev/null 2>&1
            echo "$(ansi bold_green Logged out.)"
        else
            bw logout > /dev/null 2>&1
        fi
    fi
}

cleanup() {
    logoutFromVault
    if [[ ${generatedTempDir} ]]; then
        rm -rf "${generatedTempDir}" > /dev/null 2>&1 || warn "Failed to delete temp dir: ${generatedTempDir}"
    fi
}

# Load core library

source "${HOME}/.rayvn/boot.sh" 2>/dev/null || { echo 'rayvn not installed' && exit 0; }
require 'core/base'
require 'core/spinner'

# Define required executables (checked in main to avoid delay with help).

declare -A requiredExecutables=(

    [bw_min]='2025.1.0'
    [bw_brew]=false
    [bw_install]='https://bitwarden.com/download/#downloads-command-line-interface'
    [bw_version]='versionExtract'

    [rage_min]='0.11.1'
    [rage_brew]=true
    [rage_brew_tap]='str4d.xyz/rage https://str4d.xyz/rage'
    [rage_install]='https://github.com/str4d/rage'
    [rage_version]='versionExtract'

    [jq_min]='1.7.1'
    [jq_brew]=true
    [jq_install]='https://jqlang.github.io/jq/download/'
    [jq_version]='versionExtractDash'
)

main "${@}"
