#!/usr/bin/env bash
# shellcheck disable=SC2155

declare -grx BW_BACKUP_VERSION='0.1.0'

# TODO: what to do about account recovery code?

# shellcheck disable=SC2120
usage() {
    echo
    echo "$(ansi bold Create a backup of a Bitwarden vault or restore a vault from one, secured by an) $(ansi cyan Age) $(ansi bold public key pair.)"
    echo
    echo "Usage: $(ansi bold_blue ${scriptName}) [backup] (-r RECIPIENT | -R PATH)... [-b BACKUP_DIR]"
    echo "       $(ansi bold_blue ${scriptName}) restore BACKUP_FILE -i IDENTITY"
    echo
    echo "The Bitwarden CLI is used to access the vault. Login/unlock requires user input: credentials are never stored."
    echo "Using an API key simplifies login, requiring only master password input rather than full credentials. This is"
    echo "enabled by setting the BW_CLIENTID and BW_CLIENTSECRET environment variables, for details see"
    echo "$(ansi blue https://bitwarden.com/help/personal-api-key/)."
    echo
    echo "Backup files are encrypted with $(ansi cyan Age) public keys â€” see $(ansi blue ${rageProjectUrl}) for details on features"   # TODO: sage keys !!!
    echo "and key creation. In the $(ansi cyan Age) system, a public key is called a 'recipient' and a private key is called an"
    echo "'identity'. Identities/private keys $(ansi bold_italic SHOULD) be protected by a strong password for this use case, and a copy"
    echo "of both the key and password should be stored offline in $(ansi italic at least) one secure location."
    echo
    echo "$(ansi bold_green Note) A temporary directory is required during both operations, and $(ansi italic unencrypted) vault data will be stored there."
    echo "These files will be deleted by this script; however, file recovery software may still be able to read them long"
    echo "afterward. Standard security practice is to use encrypted storage to avoid this risk, so by default you will be"
    echo "prompted to agree that the temp directory is secured. If your system uses whole disk encryption, or if the"
    echo "directory specified via -t is known to be encrypted (e.g. by VeraCrypt), this prompt can be suppressed by"
    echo "setting the VALT_SECURE_TEMP_DIR environment variable (see below)."
    echo
    echo "Options:"
    echo
    echo "    -t, --temp-dir PATH            Use the directory at PATH for temporary storage."
    echo "    -r, --recipient RECIPIENT      Encrypt to the specified RECIPIENT (public key). May be repeated."
    echo "    -R, --recipients-file PATH     Encrypt to the recipients (public keys) listed at PATH. May be repeated."
    echo "    -b, --backup-dir PATH          Use the directory at PATH to store the encrypted backup."
    echo "    -p, --prefix PREFIX            Set a prefix for the backup file name."
    echo "    -u, --url URL                  Set the URL for the Bitwarden server. Defaults to ${defaultServerUrl}"
    echo "    -i, --identity IDENTITY        Restore using the identity (private key) file at IDENTITY. May be repeated."
    echo "    -l, --login                    Force full login even if API key environment variables are set."
    echo "    -h, --help                     Display usage and exit."
    echo "    --version                      Display version and exit."
    echo
    echo "Environment Variables"
    echo
    echo "    BW_CLIENTID                    Set the Bitwarden API key."
    echo "    BW_CLIENTSECRET                Set the Bitwarden API key secret."
    echo "    VALT_BACKUP_DIR                Set the default backup destination directory."
    echo "    VALT_BACKUP_PREFIX             Set default backup file name prefix."
    echo "    VALT_RECIPIENT                 Set default recipient. May be a path to a recipients file."
    echo "    VALT_IDENTITY                  Set default identity file."
    echo "    VALT_SECURE_TEMP_DIR           Set the default secure temp directory. Use '@' to create a path via $(ansi italic mktemp)."
    echo "    VALT_PASSWORD_VISIBILITY       Set the visibility of password entry characters: none, hide, show. Default: none"
    bye "${@}"
}

main() {
    [[ ${VALT_DEBUG} ]] && setDebug
    assertExecutables valt_dependencies
    init "${@}"
    prepareVault
    if [[ ${restoreFile} ]]; then
        restoreVault
    else
        backupVault
    fi
}

init() {
    [[ ${LANG} =~ .UTF-8 ]] || warn "The LANG env var should be a UTF-8 type, but is ${LANG}"

    readonly scriptName="$(basename "${0}")"
    readonly rageProjectUrl='https://github.com/str4d/rage'
    readonly defaultServerUrl='https://vault.bitwarden.com'
    readonly backupFileSuffix='valt'
    readonly vaultFileName='vault.json'
    readonly importVaultFileName='import-vault.json'
    readonly attachmentsDirName='attachments'
    readonly restoreNoteName='ðŸ”¥ Restored Vault'
    readonly doneCheck=". ${_greenCheckMark}"
    declare -grx passwordVisibility="${VALT_PASSWORD_VISIBILITY:-none}"

    useRayvnPinEntry

    namePrefix="${VALT_BACKUP_PREFIX}"
    vaultUrl=
    backupFile=
    restoreFile=
    suppliedTempDir="${VALT_SECURE_TEMP_DIR}"
    backupDir="${VALT_BACKUP_DIR}"
    recipients="${VALT_RECIPIENT}"
    identities="${VALT_IDENTITY}"

    [[ ${suppliedTempDir} && ${suppliedTempDir} != @ ]] && setDirVar suppliedTempDir "${suppliedTempDir}"
    [[ ${backupDir} ]] && setDirVar backupDir "${backupDir}"
    [[ ${recipients} && -f ${recipients} ]] && recipients="-R ${recipients}" || recipients="-r ${recipients}"

    while ((${#} > 0)); do
        case "${1}" in
        backup) unset restoreFile ;;
        restore) shift; setFileVar restoreFile "${1}" ;;
        -t | --temp-dir) shift; setDirVar suppliedTempDir "${1}" "secure temp dir path" ;;
        -r | --recipient) shift; appendVar recipients "-r ${1}" ;;
        -R | --recipients-file) shift; assertFile "${1}" "recipients file"; appendVar recipients "-R ${1}" ;;
        -i | --identity) shift; assertFile "${1}" "identities file"; appendVar identities "-i ${1}" ;;
        -b | --backup-dir) shift; setDirVar backupDir "${1}" "backup dir path" ;;
        -p | --prefix) shift; namePrefix="${1}" ;;
        -u | --url) shift; vaultUrl="${1}" ;;
        -l | --login) unset BW_CLIENTID BW_CLIENTSECRET BW_SESSION VALT_DEV_BW_PWD ;;
        --update) update-bw; exit 0 ;;
        -h | --help) usage ;;
        -v | --version) version "${VALT_BACKUP_VERSION}" ;;
        *) fail "Unknown argument: ${1}" ;;
        esac
        shift
    done

    [[ ${vaultUrl} ]] || vaultUrl="${defaultServerUrl}"

    if [[ ! ${restoreFile} ]]; then

        # backup

        [[ ${recipients} ]] || fail "one or more recipients required"
        [[ ${namePrefix} ]] || namePrefix="${USER}"
        readonly backupName="${namePrefix}-backup-$(timeStamp)"

        if [[ ${backupDir} ]]; then
            backupFile="${backupDir}/${backupName}.${backupFileSuffix}"
        else
            backupFile="${backupName}.${backupFileSuffix}"
        fi
    else

        # restore

        [[ ${identities} ]] || fail "one or more identities required"
        readonly backupName="$(basename ${restoreFile} | cut -d'.' -f1-3)"
    fi

    addExitHandler cleanup

    initSecureTempDir
    readonly secureWorkDir="$(makeDir "${secureTempDir}" "${backupName}")"
    chmod 700 "${secureWorkDir}" || fail
    readonly vaultFile="${secureWorkDir}/vault.json"
    readonly attachmentsDir="$(makeDir ${secureWorkDir} attachments)"
}

initSecureTempDir() {
    local verifySecure
    if [[ ${suppliedTempDir} == '' || ${suppliedTempDir} == '@' ]]; then

        # Use the rayvn system temp dir which will be deleted by rayvn on exit

        secureTempDir="$(tempDirPath)"

    else

        # User supplied, so generate a temp dir within it. Remember the generated dir
        # to ensure we delete it on exit

        local randomDirName="$(basename "$(mktemp -d -u)")" || fail
        suppliedTempDir="${suppliedTempDir}"
        generatedTempDir="$(makeDir ${suppliedTempDir} ${randomDirName})"
        secureTempDir=${generatedTempDir}
        verifySecure=true
    fi
    [[ -d ${secureTempDir} ]] || fail "Secure temp directory ${secureTempDir} not found!"
    cd "${secureTempDir}" || fail
    [[ ${verifySecure} ]] && verifySecureTempDir
}

setDebug() {
    declare -grx _debug=true
    declare -grx _debugDir="${HOME}/.valt"
    declare -grx _debugFile="${_debugDir}/log"
    [[ -e ${_debugDir} ]] && (rm -rf "${_debugDir}" || fail)
    mkdir "${_debugDir}" || fail
    exec 3> "${_debugFile}"
    printf "___ valt log $(date) _________________________________\n\n" >&3
}

debugStatus() {
    [[ ${_debug} ]] && echo "Debug enabled, log at $(ansi blue ${_debugFile}) ${_greenCheckMark}"
}

debug() {
    [[ ${_debug} ]] && echo "${@}" >&3
}

debugVar() {
    if [[ ${_debug} ]]; then
        for varName in "$@"; do
            declare -p ${varName} >&3
        done
    fi
}

debugFile() {
    if [[ ${_debug} ]]; then
        local sourceFile="${1}"
        local fileName="${2:-$(baseName ${sourceFile})}"
        local destFile="${_debugDir}/${fileName}"
        cp "${sourceFile}" "${destFile}"
    fi
}

debugJson() {
    if [[ ${_debug} ]]; then
        local -n json="${1}"
        local fileName="${2}"
        local destFile="${_debugDir}/${fileName}.json"
        debug "created ${destFile}"
        echo "${json}" > "${destFile}"
    fi
}

verifySecureTempDir() {
    local source
    local reply
    [[ ${generatedTempDir} ]] && source="supplied '${suppliedTempDir}' as root of" || source="system"
    echo
    echo "$(ansi bold Verify configuration)"
    echo
    echo "Using ${source} temp directory: $(ansi blue ${secureTempDir})"
    echo
    read -t 30 -p "This directory SHOULD be encrypted to avoid leaking sensitive data. $(ansi bold_green Proceed?) [yes/no]: " reply
    if [[ ${reply,,} != 'yes' ]]; then
        echo
        fail "See help for more about this issue: ${scriptName} --help"
    fi
}

prepareVault() {
    echo
    if [[ ${restoreFile} ]]; then
        echo "$(ansi bold Restore Backup)"
    else
        echo "$(ansi bold Create Backup)"
    fi
    echo
    debugStatus
    if ! useParentSession; then
        ensureLatestCLI
        unlockVault
    fi
    syncVault
}

useParentSession() {
    if [[ ${VALT_USE_PARENT_SESSION} && ${BW_SESSION} ]]; then
        if [[ $(sessionStatus) == unlocked ]]; then
            echo "Skipping login, parent session appears valid${doneCheck}"
            return 0
        fi
    fi
    return 1
}

ensureLatestCLI() {
    startSpinner "Checking Bitwarden CLI version"
    local update="$(bw update 2>&1)"
    bwPath=$(command -v bw)
    if [[ ${update} =~ "new version" ]]; then
        stopSpinner ": $(ansi bold_red ${bwPath} is out of date.)"
        echo
        echo "${update}"
        fail
    fi
    stopSpinner ": $(ansi blue "${bwPath}") is up to date at $(bw --version)${doneCheck}"
}

sessionStatus() {
    bw status | jq -r '.status'
}

unlockVault() {
    startSpinner "Unlocking vault"

    logoutFromVault force # just in case there is an active session
    declare -gx BW_SESSION

    bw config server "${vaultUrl}" > /dev/null

    if [[ ${BW_CLIENTID} ]]; then

        # Use api key to login

        bw login --apikey > /dev/null || failSpin "login with api key failed"

        # Unlock vault

        openVault unlock

    else

        # Login and unlock without api key

        openVault login
    fi

    [[ ${BW_SESSION} ]] || failSpin "unlock failed"
}

openVault() {
    local command=${1}
    if [[ ${VALT_DEV_BW_PWD} ]]; then
        useDevPassword ${command}
    else
        useCredentials ${command}
    fi
}
useDevPassword() {
    local command=${1}
    debug "useDevPassword ${command}"
    [[ ${command} == login ]] && stopSpinner ". Credentials required..."
    BW_SESSION="$(bw ${command} --raw --passwordenv VALT_DEV_BW_PWD)"
    [[ ${command} == unlock ]] && stopSpinner "${doneCheck}"
}
useCredentials() {
    local command=${1}
    stopSpinner ". Credentials required..."
    debug "useCredentials ${command}"
    for retryIndex in {1..3}; do
        BW_SESSION="$(bw ${command} --raw)" && break
    done
}
syncVault() {
    startSpinner "Syncing vault"
    bw sync > /dev/null || fail
    stopSpinner "${doneCheck}"
}

backupVault() {
    local items item
    local attachmentItemIds attachmentItemId
    local attachments attachment
    local attachDir
    startSpinner "Backing up vault"

    bw export --raw --format json > "${vaultFile}" || failSpin

    items="$(bw list items)"

    attachmentItemIds="$(echo ${items} | jq -r ".[] | select(.attachments).id")"

    for attachmentItemId in ${attachmentItemIds}; do
        item="$(echo "${items}" | jq -r ".[] | select(.id == \"${attachmentItemId}\")")"
        attachments="$(echo "${item}" | jq -r ".attachments")"
        length="$(echo "${attachments}" | jq -r ". | length")"

        for ((retryIndex = 0; retryIndex < ${length}; retryIndex++)); do
            attachDir="$(makeDir ${attachmentsDir} ${attachmentItemId})"

            attachment="$(echo "${attachments}" | jq ".[${retryIndex}]")"
            attachmentId="$(echo "${attachment}" | jq -r ".id")"
            fileName="$(echo "${attachment}" | jq -r ".fileName")"

            # get attachment

            bw get attachment "${attachmentId}" --itemid "${attachmentItemId}" \
                --output "${attachDir}/${fileName}" >/dev/null 2>&1 || failSpin
        done
    done

    # TODO can recipients be encrypted?
    tar cz "${backupName}" | rage ${recipients} > ${backupFile} || failSpin
    local size="$(du -h "${backupFile}" | cut -d' ' -f2 | cut -d $'\t' -f1)"

    stopSpinner "${doneCheck}"
    logoutFromVault
    echo
    echo "$(ansi bold_green Vault backed up to) ${backupFile} $(ansi bold_green size): $(ansi bold ${size})"
}

restoreVault() {

    # There are two issues with restoring a vault that make this implementation far more complicated
    # than expected/desirable:
    #
    #  1. Importing a vault REPLACES the item ids and creation/revision dates with NEW ones, therefore
    #  2. Restoring attachments requires MAPPING the old ids (from the backup) to the NEW ones.
    #
    # A reasonable case can be made that issue #1 is a bug. If fixed, BOTH issues go away.
    #
    # Since we MUST restore attachments, and we SHOULD use the original dates, we workaround these issues
    # using this high level approach:
    #
    #    import the backup -> export the result -> edit each item -> upload attachments
    #
    # Restore Procedure
    #
    #  0. ensure target vault is EMPTY
    #  1. unlock/unpack backup to temp dir
    #  2. load vault.json into ${oldVault}
    #  3. extract stats from ${oldVault}
    #  4. for each item in ${oldVault}, modify name with its index number. Used to map item ids independent of export order.
    #  5. create an oldIds array by extraction from ${oldVault}
    #  6. import ${oldVault} to target.
    #  7. export target vault to ${newVault}
    #  8. for each item in ${oldVault}, set oldId from oldIds(${i}) and:
    #       a. set oldId from ${oldIds} using loop index
    #       a. extract newItem from ${newVault} using loop index
    #       b. extract newId from ${newItem}
    #       c. update ${idMap} with ${oldId} -> ${newId} for attachment processing
    #       b. edit item ${newId} and update it with:
    #           1. name stripped of index prefix
    #           2. creation date from old item
    #           3. revision date from old item
    #           4. deleted date from old item
    #  9. create note item in target with stats
    # 10. restore attachments using ${idMap}
    #
    # NOTE: At present, an edit with any of the original dates fails; an issue has been created
    # (https://github.com/bitwarden/clients/issues/13429) and the code is commented until a fix is implemented.

    local backupFile="${restoreFile}"
    local backupFileName="$(basename ${backupFile})"
    local oldIds=()
    declare -A idMap=()

    assertVaultReady  # (STEP 0)

    # Extract contents of decrypted backup file to secureWorkDir (STEP 1)

    echo "Preparing backup. You will be prompted for your private key passphrase if encrypted."
    cd "${secureWorkDir}" || fail
    local tarFile="backup.tar"
    rage -d ${identities} "${backupFile}" -o "${tarFile}" 2> >(redStream) || fail

    startSpinner "Preparing import" # don't start until here, since the above will likely prompt for a password
    tar -xf "${tarFile}" --strip-components=1 || fail
    rm "${tarFile}" || fail

    # Get vault and grab some stats from it (STEPS 2 & 3)

    local oldVault="$(cat "${vaultFileName}")"
    local itemsCount=$(echo "${oldVault}" | jq '.items // 0 | length')
    local foldersCount=$(echo "${oldVault}" | jq '.folders // 0 | length')
    local attachmentsCount="$(find attachments -type f | wc -l | awk '{print $1}')"

    # Update the names with sequence number prefixes so we can correctly map them later (STEP 4)

    debugJson oldVault 'before'
    prefixNamesWithIndex oldVault ${itemsCount}
    debugJson oldVault 'after'

    # Extract old item ids (STEP 5)

    mapfile -t oldIds < <(echo "${oldVault}" | jq -r '.items[].id')

    # Import updated vault (STEP 6)

    restartSpinner "${doneCheck}" "Importing vault"
    echo "${oldVault}" > "${importVaultFileName}"
    bw import bitwardenjson "./${importVaultFileName}" > /dev/null || fail

    # Export vault (STEP 7)

    local newVault="$(bw export --format json --raw)" || fail

    # Edit each item in the new vault to fix name and copy old dates, building idMap (STEP 8)

    local suffix="$( (( itemsCount < 10 )) && echo '' || echo ' (this may take some time)')"
    restartSpinner "${doneCheck}" "Restoring ${itemsCount} items${suffix}"
    restoreItems oldVault newVault oldIds idMap ${itemsCount}

    # Add a note (STEP 9)

    addNote "${backupFile}" ${itemsCount} ${foldersCount} ${attachmentsCount}

    # Process attachments if we have any (STEP 10)

    if (( ${attachmentsCount} > 0 )); then
        restartSpinner "${doneCheck}" "Uploading ${attachmentsCount} attachments"
        uploadAttachments idMap
    fi

    stopSpinner "${doneCheck}"

    logoutFromVault

    echo
    echo "$(ansi bold_green Restore completed.)"
    echo
    echo "A note named '${restoreNoteName}' was added to your vault with details of this operation."
    echo
    suffix="$( (( attachmentsCount > 0 )) && echo ' and attachments.' || echo '.')"
    echo "You will likely need to logout/login to see all restored items${suffix}"
}

prefixNamesWithIndex() {   # STEP 4
    local -n vaultRef=${1}
    local itemsCount=${2}
    local name newName
    local tempVault="${vaultRef}" # TODO don't need this indirection

    for ((i = 0; i < itemsCount; i++)); do
        name=$(echo "${tempVault}" | jq -r --argjson i ${i} '.items[$i].name')
        newName="<${i}> ${name}"
        tempVault=$(echo "${tempVault}" | jq --argjson i ${i} --arg name "${newName}" '.items[$i].name=$name')
    done
    vaultRef="${tempVault}"
}

restoreItems() { # STEP 8

    local -n oldVaultRef=${1}
    local -n newVaultRef=${2}
    local -n oldIdsRef=${3}
    local -n idMapRef=${4}
    local itemsCount=${5}
    local i oldId newId newItem indexedName name newItem restoredItem editedItem # cDate rDate dDate

    for (( i = 0; i < itemsCount; i++ )); do

        # Get the oldId and oldItem

        oldId=${oldIdsRef[${i}]}
        oldItem=$(echo ${oldVaultRef} | jq -r --arg id "${oldId}" '.items[] | select(.id == $id)')

        # Lookup the newItem by index and extract newId

        newItem=$(echo "${newVaultRef}" | jq -r --arg index ${i} '.items[] | select(.name | startswith("<" + ($index|tostring) + ">"))')
        newId=$(echo "${newItem}" | jq -r '.id')

        # Update the idMap for attachment processing

        idMapRef["${oldId}"]="${newId}"

        # Get the item name without the index prefix

        indexedName=$(echo ${newItem} | jq -r '.name')
        name="${indexedName#\<[0-9]*\> }"

        debug ''; debugVar i oldId newId indexedName name

        # Update newItem

# TODO See https://github.com/bitwarden/clients/issues/13429
#
#        cDate=$(echo ${oldItem} | jq -r '.creationDate')
#        rDate=$(echo ${oldItem} | jq -r '.revisionDate')
#        dDate=$(echo ${oldItem} | jq -r '.deletedDate')
#
#        restoredItem=$(echo "${newItem}" | jq -c --arg name "${name}" --arg id "${newId}" --arg c "${cDate}" --arg r "${rDate}" --arg d "${dDate}" \
#            '.name=$name | .id=$id | .creationDate=$c | .revisionDate=$r | .deletedDate=$d' )

        restoredItem=$(echo "${newItem}" | jq -c --arg name "${name}"  --arg id "${newId}" '.name=$name | .id=$id')
        debugJson restoredItem "restoredItem-${i}"

        # Finally, edit the item in the vault to restore it

        editedItem=$(echo "${restoredItem}" | bw encode | bw edit item "${newId}")
        debugJson editedItem "editedItem-${i}"

    done
}

addNote() {  # STEP 9
    local source="${1}"
    local items=${2}
    local folders=${3}
    local attachments=${4}
    local i=$( [[ ${items} == 1 ]] && echo item || echo items)
    local f=$( [[ ${folders} == 1 ]] && echo folder || echo folders)
    local a=$( [[ ${items} == 1 ]] && echo attachment || echo attachments)
    local format='Restored on %s\n\n%d %s, %d %s, %d %s from %s\n'
    note="$(printf "${format}" "$(date)" ${items} ${i} ${folders} ${f} ${attachments} ${a} "${source}")"

    # TODO Add hostname, username, uname, IP, reverse dns... https://iplocation.io/ ip.info ???

    debugJson note

    local temp=$(bw get template item) || fail
    local name="${restoreNoteName}"
    local item=$(echo ${temp} | jq -r --arg nm "${name}" --arg nt "${note}" '.type=2 | .secureNote.type=0 | .name=$nm | .notes=$nt')
    echo ${item} | bw encode | bw create item > /dev/null || fail
}

uploadAttachments() { # STEP 10
    local -n idMapRef=${1}
    local attachmentDir attachmentFile
    pushd "${attachmentsDirName}" > /dev/null || fail

    for attachmentDir in ./*; do

        pushd "${attachmentDir}" > /dev/null || fail
        local oldAttachmentItemId="$(basename ${attachmentDir})"
        local newAttachmentItemId="${idMapRef[${oldAttachmentItemId}]}"
        debugVar oldAttachmentItemId newAttachmentItemId

        for attachmentFile in ./*; do
            debugVar attachmentFile
            bw create attachment --file "./${attachmentFile}" --itemid "${newAttachmentItemId}" > /dev/null || fail
        done
        popd > /dev/null || fail
    done
}

assertVaultReady() {
    startSpinner "Checking vault"

    local vault="$(bw export --raw --format json)"

    local orgVault="$(echo "${vault}" | jq '.collections != null' | grep true)"
    [[ ${orgVault} ]] && failSpin "Cannot restore to an Organization vault (yet)."

    local itemsCount=$(echo "${vault}" | jq '.items // 0 | length')
    (( itemsCount == 0 )) || failVaultNotEmpty

    local foldersCount=$(echo "${vault}" | jq '.folders // 0 | length')
    (( foldersCount == 0 )) || failVaultNotEmpty
    stopSpinner "${doneCheck}"
}

failVaultNotEmpty() {
    stopSpinner ": $(ansi red vault must be empty before restoring to it.)"
    echo
    echo "If you are not $(ansi bold_italic sure) that you have a current backup, make another one or restore"
    echo "to a new account (with a Premium subscription if you have attachments)."
    echo
    echo "If you choose to empty the target vault:"
    echo
    echo "  1. In a browser, login at $(ansi blue ${vaultUrl})."
    echo "  2. In the left pane, under $(ansi bold Settings), click $(ansi bold My Account)."
    echo "  3. In the $(ansi red Danger zone) section, click $(ansi red Purge vault)."
    echo "  4. In the popup, enter you master password and click $(ansi red Purge vault)."
    fail
}

logoutFromVault() {
    local arg=${1}
    if [[ ${arg} == force ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    elif [[ ${BW_SESSION} && ! ${VALT_USE_PARENT_SESSION} ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    fi
}

cleanup() {
    logoutFromVault

    [[ ${debug} ]] && exec 3<&- # close file descriptor

    if [[ ${generatedTempDir} ]]; then
        rm -rf "${generatedTempDir}" > /dev/null 2>&1 || warn "Failed to delete temp dir: ${generatedTempDir}"
    fi
}

update-bw () { # TODO: harden and expose command!
    local url="${1}"
    local installFile="$(command -v bw)"
    local installDir="$(dirname ${installFile})"
    echo "Installed version: $(${installFile} --version)"
    if [[ ! ${url} ]]; then
        local response="$(bw update | grep http)"
        if [[ ${response} ]]; then
            url="http${response##*http}"
        fi
    fi
    if [[ "${url}" ]]; then
        local tempFile="${installFile}.zip"
        curl "${url}" -L -o "${tempFile}" 2> /dev/null || return
        rm "${installFile}" 2>&1 > /dev/null
        unzip -q -u "${tempFile}" -d "${installDir}"
        rm "${tempFile}" || return
        chmod +x "${installFile}" || return
        echo "       Updated to: $(${installFile} --version)"
    else
        echo "No update available."
    fi
}

# Load rayvn library


source "${HOME}/.rayvn/boot.sh" &> /dev/null || { echo 'rayvn not installed'; exit 1; }
require 'rayvn/core'
require 'rayvn/spinner'

# Define required executables (assertion in main to avoid delay with help).

declare -grxA valt_dependencies=(

    [bw_min]='2025.1.0'
    [bw_brew]=false
    [bw_install]='https://bitwarden.com/download/#downloads-command-line-interface'
    [bw_version]='versionExtract'

    [rage_min]='0.11.1'
    [rage_brew]=true
    [rage_brew_tap]='str4d.xyz/rage https://str4d.xyz/rage'
    [rage_install]='https://github.com/str4d/rage'
    [rage_version]='versionExtract'

    [jq_min]='1.7.1'
    [jq_brew]=true
    [jq_install]='https://jqlang.github.io/jq/download/'
    [jq_version]='versionExtractDash'
)

main "${@}"
