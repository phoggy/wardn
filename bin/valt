#!/usr/bin/env bash
# shellcheck disable=SC2155

declare -grx BW_BACKUP_VERSION='bw-backup 0.1.0'

# TODO: what to do about account recovery code?

# shellcheck disable=SC2120
usage() {
    echo
    echo "$(ansi bold Create a backup of a Bitwarden vault or restore a vault from one, secured by an) $(ansi cyan Age) $(ansi bold public key pair.)"
    echo
    echo "Usage: $(ansi bold_blue ${scriptName}) [backup] (-r RECIPIENT | -R PATH)... [-b BACKUP_DIR]"
    echo "       $(ansi bold_blue ${scriptName}) restore BACKUP_FILE -i IDENTITY"
    echo
    echo "The Bitwarden CLI is used to access the vault. Login/unlock requires user input: credentials are never stored."
    echo "Using an API key simplifies login, requiring only master password input rather than full credentials. This is"
    echo "enabled by setting the BW_CLIENTID and BW_CLIENTSECRET environment variables, for details see"
    echo "$(ansi blue https://bitwarden.com/help/personal-api-key/)."
    echo
    echo "The Bitwarden CLI is used, and  and an API key and secret is required, both of which must be "
    echo
    echo "Backup files are encrypted with $(ansi cyan Age) public keys â€” see $(ansi blue ${rageProjectUrl}) for details on features"
    echo "and key creation. In the $(ansi cyan Age) system, a public key is called a 'recipient' and a private key is called an"
    echo "'identity'. Identities/private keys $(ansi bold_italic SHOULD) be protected by a strong password for this use case, and a copy"
    echo "of both the key and password should be stored offline in $(ansi italic at least) one secure location."
    echo
    echo "$(ansi bold_green Note) A temporary directory is required during both operations, and $(ansi italic unencrypted) vault data will be stored there."
    echo "These files will be deleted by this script; however, file recovery software may still be able to read them long"
    echo "afterward. Standard security practice is to use encrypted storage to avoid this risk, so by default you will be"
    echo "prompted to agree that the temp directory is secured. If your system uses whole disk encryption, or if the"
    echo "directory specified via -t is known to be encrypted (e.g. by VeraCrypt), this prompt can be suppressed by"
    echo "setting the BW_BACKUP_TEMP_DIRECTORY environment variable (see below)."
    echo
    echo "Options:"
    echo
    echo "    -t, --temp-dir PATH            Use the directory at PATH for temporary storage."
    echo "    -r, --recipient RECIPIENT      Encrypt to the specified RECIPIENT (public key). May be repeated."
    echo "    -R, --recipients-file PATH     Encrypt to the recipients (public keys) listed at PATH. May be repeated."
    echo "    -b, --backup-dir PATH          Use the directory at PATH to store the encrypted backup."
    echo "    -p, --prefix PREFIX            Set a prefix for the backup file name."
    echo "    -u, --url URL                  Set the URL for the Bitwarden server. Defaults to ${defaultServerUrl}"
    echo "    -i, --identity IDENTITY        Restore using the identity (private key) file at IDENTITY. May be repeated."
    echo "    -h, --help                     Display usage and exit."
    echo "    --version                      Display version and exit."
    echo
    echo "Environment Variables"
    echo
    echo "    BW_CLIENTID                    Set the Bitwarden API key."
    echo "    BW_CLIENTSECRET                Set the Bitwarden API key secret."
    echo "    BW_BACKUP_PREFIX               Set default backup name prefix."
    echo "    BW_BACKUP_RECIPIENT            Set default recipient. May be a path to a recipients file."
    echo "    BW_BACKUP_DIR                  Set the default backup directory."
    echo "    BW_BACKUP_SECURE_TEMP_DIR      Set the default secure temp directory. Use '@' to create a path via $(ansi italic mktemp)."
    echo "    BW_BACKUP_PASSWORD_VISIBILITY  Set the visibility of password entry characters: none, hide, show. Default: none"
    bye "${@}"
}

main() {
    assertExecutables requiredExecutables
    init "${@}"
    if ! useParentSession; then
        ensureLatestCLI
        loginToVault
    fi
    syncVault
    if [[ ${restoreFile} ]]; then
        restoreVault
    else
        backupVault
    fi
    logoutFromVault verbose
}

init() {
    [[ ${LANG} =~ .UTF-8 ]] || warn "The LANG env var should be a UTF-8 type, but is ${LANG}"

    readonly scriptName="$(basename "${0}")"
    readonly rageProjectUrl='https://github.com/str4d/rage'
    readonly defaultServerUrl="https://vault.bitwarden.com"
    readonly backupFileSuffix="tar.gz.age"
    readonly vaultFileName="vault.json"
    readonly importVaultFileName="import-vault.json"
    readonly attachmentsDirName="attachments"
    readonly bwDateFormat='%Y-%m-%dT%H:%M:%S.000Z' # date cmd on Mac does not support ms
    readonly restoreNoteName="ðŸ”¥ Restored Vault ðŸ”¥"
    readonly restoredNoteId="restored-note-xxxx-xxxx-xxxxxxxxxxxx"
    readonly logFile="${HOME}/valt.log"
    declare -grx passwordVisibility="${VALT_BACKUP_PASSWORD_VISIBILITY:-none}"
    echo '' > "${logFile}"

    useRayvnPinEntry

    namePrefix="${VALT_BACKUP_PREFIX}"
    vaultUrl=
    identities=
    backupFile=
    restoreFile=
    suppliedTempDir="${VALT_BACKUP_SECURE_TEMP_DIR}"
    backupDir="${VALT_BACKUP_DIR}"
    recipients="${VALT_BACKUP_RECIPIENT}"

    [[ ${suppliedTempDir} && ${suppliedTempDir} != @ ]] && setDirVar suppliedTempDir "${suppliedTempDir}"
    [[ ${backupDir} ]] && setDirVar backupDir "${backupDir}"
    [[ ${recipients} && -f ${recipients} ]] && recipients="-R ${recipients}" || recipients="-r ${recipients}"

    while ((${#} > 0)); do
        case "${1}" in
        backup) unset restoreFile ;;
        restore) shift; setFileVar restoreFile "${1}" ;;
        -t | --temp-dir) shift; setDirVar suppliedTempDir "${1}" "secure temp dir path" ;;
        -r | --recipient) shift; appendVar recipients "-r ${1}" ;;
        -R | --recipients-file) shift; assertFile "${1}" "recipients file"; appendVar recipients "-R ${1}" ;;
        -i | --identity) shift; assertFile "${1}" "identities file"; appendVar identities "-i ${1}" ;;
        -b | --backup-dir) shift; setDirVar backupDir "${1}" "backup dir path" ;;
        -p | --prefix) shift; namePrefix="${1}" ;;
        -u | --url) shift; vaultUrl="${1}" ;;
        -h | --help) usage ;;
        -v | --version) version "${VALT_BACKUP_VERSION}" ;;
        *) fail "Unknown argument: ${1}" ;;
        esac
        shift
    done

    [[ ${vaultUrl} ]] || vaultUrl="${defaultServerUrl}"

    if [[ ! ${restoreFile} ]]; then

        # backup

        [[ ${recipients} ]] || fail "one or more recipients required"
        [[ ${namePrefix} ]] || namePrefix="${USER}"
        readonly backupName="${namePrefix}-backup-$(timeStamp)"

        if [[ ${backupDir} ]]; then
            backupFile="${backupDir}/${backupName}.${backupFileSuffix}"
        else
            backupFile="${backupName}.${backupFileSuffix}"
        fi
    else

        # restore

        [[ ${identities} ]] || fail "one or more identities required"
        readonly backupName="$(basename ${restoreFile} | cut -d'.' -f1-3)"
    fi

    addExitHandler cleanup

    initSecureTempDir
    readonly secureWorkDir="$(makeDir "${secureTempDir}" "${backupName}")"
    chmod 700 "${secureWorkDir}" || fail
    readonly vaultFile="${secureWorkDir}/vault.json"
    readonly attachmentsDir="$(makeDir ${secureWorkDir} attachments)"
}

initSecureTempDir() {
    local verifySecure
    if [[ ${suppliedTempDir} == '' || ${suppliedTempDir} == '@' ]]; then

        # Use the rayvn system temp dir which will be deleted by rayvn on exit

        secureTempDir="$(tempDirPath)"

    else

        # User supplied, so generate a temp dir within it. Remember the generated dir
        # to ensure we delete it on exit

        local randomDirName="$(basename "$(mktemp -d -u)")" || fail
        suppliedTempDir="${suppliedTempDir}"
        generatedTempDir="$(makeDir ${suppliedTempDir} ${randomDirName})"
        secureTempDir=${generatedTempDir}
        verifySecure=true
    fi
    [[ -d ${secureTempDir} ]] || fail "Secure temp directory ${secureTempDir} not found!"
    cd "${secureTempDir}" || fail
    [[ ${verifySecure} ]] && verifySecureTempDir
}

verifySecureTempDir() {
    local source
    local reply
    [[ ${generatedTempDir} ]] && source="supplied '${suppliedTempDir}' as root of" || source="system"
    echo
    echo "$(ansi bold Verify configuration)"
    echo
    echo "Using ${source} temp directory: $(ansi blue ${secureTempDir})"
    echo
    read -t 30 -p "This directory SHOULD be encrypted to avoid leaking sensitive data. $(ansi bold_green Proceed?) [yes/no]: " reply
    if [[ ${reply,,} != 'yes' ]]; then
        echo
        fail "See help for more about this issue: ${scriptName} --help"
    fi
}

ensureLatestCLI() {
    echo
    echo "$(ansi bold_blue Checking Bitwarden CLI version)"
    echo
    local update="$(bw update 2>&1)"
    if [[ ${update} =~ "new version" ]]; then
        printRed "The Bitwarden CLI at $(which bw) is out of date."
        echo
        echo "${update}"
        fail
    fi
    echo "$(ansi bold_green "$(which bw)") is the latest version ($(bw --version))"
}

useParentSession() {
    if [[ ${VALT_USE_PARENT_SESSION} && ${BW_SESSION} ]]; then
        if [[ $(sessionStatus) == unlocked ]]; then
            echo
            echo "$(ansi bold_italic Using parent session)"
            return 0
        fi
    fi
    return 1
}

sessionStatus() {
    bw status | jq -r .status
}

loginToVault() {
    echo
    echo "$(ansi bold_blue Logging in to vault)"
    echo
    startSpinner

    logoutFromVault force # just in case there is an active session
    declare -gx BW_SESSION

    bw config server "${vaultUrl}" > /dev/null

    if [[ ${BW_CLIENTID} ]]; then

        # Use api key

        bw login --apikey > /dev/null || fail "login failed"
        if [[ ${VALT_BACKUP_DEV_PWD} ]]; then
            BW_SESSION="$(bw unlock --raw --passwordenv VALT_BACKUP_DEV_PWD)"
        else
            for retryIndex in {1..3}; do
                echo
                BW_SESSION="$(bw unlock --raw)" && break
            done
        fi
        stopSpinner
    else
        stopSpinner
        if [[ ${VALT_BACKUP_DEV_PWD} ]]; then
            BW_SESSION="$(bw login --raw --passwordenv VALT_BACKUP_DEV_PWD)"
        else
            for retryIndex in {1..3}; do
                echo
                BW_SESSION="$(bw login --raw)" && break
            done
        fi
        echo
    fi

    [[ ${BW_SESSION} ]] || fail "login failed"

    echo "$(ansi bold_green Logged in.)"
}

syncVault() {
    echo
    echo "$(ansi bold_blue Syncing vault)"
    echo
    bw sync > /dev/null || fail
    echo "Vault is current."
}

backupVault() {
    local items item
    local attachmentItemIds attachmentItemId
    local attachments attachment
    local attachDir
    echo
    echo "$(ansi bold_blue Backing up vault)  "
    echo
    startSpinner

    bw export --raw --format json > "${vaultFile}" || failSpin

    items="$(bw list items)"

    attachmentItemIds="$(echo ${items} | jq -r ".[] | select(.attachments).id")"

    for attachmentItemId in ${attachmentItemIds}; do
        item="$(echo "${items}" | jq -r ".[] | select(.id == \"${attachmentItemId}\")")"
        attachments="$(echo "${item}" | jq -r ".attachments")"
        length="$(echo "${attachments}" | jq -r ". | length")"

        for ((retryIndex = 0; retryIndex < ${length}; retryIndex++)); do
            attachDir="$(makeDir ${attachmentsDir} ${attachmentItemId})"

            attachment="$(echo "${attachments}" | jq ".[${retryIndex}]")"
            attachmentId="$(echo "${attachment}" | jq -r ".id")"
            fileName="$(echo "${attachment}" | jq -r ".fileName")"

            # get attachment

            bw get attachment "${attachmentId}" --itemid "${attachmentItemId}" \
                --output "${attachDir}/${fileName}" >/dev/null 2>&1 || failSpin
        done
    done

    # TODO can recipients be encrypted?
    tar cz "${backupName}" | rage ${recipients} > ${backupFile} || failSpin
    local size="$(du -h "${backupFile}" | cut -d' ' -f2 | cut -d $'\t' -f1)"

    stopSpinner
    echo "$(ansi bold_green Vault backed up to) ${backupFile} $(ansi bold_green size): $(ansi bold ${size})"
}

restoreVault() {    # TODO Can restore original creation/revision dates??

    # There are two issues with restoring a vault that make this implementation far more complicated
    # than expected/desirable:
    #
    #  1. Importing a vault REPLACES the item ids and creation/revision dates with NEW ones, therefore
    #  2. Restoring attachments requires MAPPING the old ids (from the backup) to the NEW ones.
    #
    # A reasonable case can be made that issue #1 is a bug. If fixed, BOTH issues go away.
    #
    # Since we MUST restore attachments, and we SHOULD use the original dates, we workaround these issues
    # using this high level approach:
    #
    #    import the backup -> export the result -> edit each item -> upload attachments
    #
    # Restore Procedure
    #
    #  0. ensure target vault is EMPTY
    #  1. unlock/unpack backup to temp dir
    #  2. load vault.json into ${oldVault}
    #  3. extract stats from ${oldVault}
    #  4. for each item in ${oldVault}, modify name with it's index number. Used to map item ids regardless of order in export step.
    #  5. create an oldIds array by extraction from ${oldVault}
    #  6. import ${oldVault} to target.
    #  7. export target vault to ${newVault}
    #  8. Use the index numbers from ${newVault} as an index to select a newId and combine it with oldIds into a map.
    #  9. for each item in ${oldVault}, get id and:
    #       a. set newId from idMap([$id])
    #       b. edit item ${newId} from target and update it with (SLOW but unavoidable for now to restore timestamps)
    #           c. name stripped of index prefix.
    #           d. creation date from old item
    #           e. revision date from old item
    #           f. deleted date from old item
    # 10. create note item in target with stats
    # 11. restore attachments using idMap
    #
    # At present, an edit with any of the original dates fails; a bug has been reported (https://github.com/bitwarden/clients/issues/13429)
    # and the code is commented until a fix is implemented.

    local backupFile="${restoreFile}"
    local backupFileName="$(basename ${backupFile})"
    local backupDate="$(basename ${backupFileName#*backup-*-} .${backupFileSuffix})"
    local doneCheck=". ${_greenCheckMark}"

    echo
    echo "$(ansi bold_blue Checking vault)"
    echo
    assertVaultEmpty  # (STEP 0)

    echo "Vault is empty."
    echo
    echo "$(ansi bold_blue Restoring vault) from $(ansi blue ${backupFileName})"
    echo

    # Extract contents of decrypted backup file to secureWorkDir (STEP 1)

    cd "${secureWorkDir}" || fail
    local tarFile="backup.tar"
    rage -d ${identities} "${backupFile}" -o "${tarFile}" 2> >(redStream) || fail
    echo

    startSpinner "Preparing import" # don't start until here, since the above will likely prompt for a password

    tar -xf "${tarFile}" --strip-components=1 || fail
    rm "${tarFile}" || fail

    # Get vault and grab some stats from it (STEPS 2 & 3)

    local oldVault="$(cat "${vaultFileName}")"
    local itemsCount=$(echo "${oldVault}" | jq '.items // 0 | length')
    local foldersCount=$(echo "${oldVault}" | jq '.folders // 0 | length')
    local attachmentsCount="$(find attachments -type f | wc -l | awk '{print $1}')"

    # Update the names with sequence number prefixes so we can correctly map them later (STEP 4)

echo "${oldVault}" | jq > "${HOME}/before.json" # TODO REMOVE
    prefixNamesWithIndex oldVault ${itemsCount}

    # Extract old item ids (STEP 5)

    local oldIds
    mapfile -t oldIds < <(echo "${oldVault}" | jq -r '.items[].id')

    # Import updated vault (STEP 6)

echo "${oldVault}" | jq > "${HOME}/after.json" || fail # TODO remove
    restartSpinner "${doneCheck}" "Performing import"
    echo "${oldVault}" > "${importVaultFileName}"
    bw import bitwardenjson "${secureWorkDir}/${importVaultFileName}" >> "${logFile}" 2>&1 || fail

    # Export vault (STEP 7)

    local newVault="$(bw export --format json --raw)" || fail

    # Build array of the new item ids (STEP 8)

    declare -A idMap=()
    buildIdMap newVault oldIds idMap ${itemsCount}

    # Edit each item in the new vault to fix name and copy old dates (STEP 9)

    local suffix="$( (( itemsCount < 10 )) && echo '' || echo ' (this may take some time)')"
    restartSpinner "${doneCheck}" "Restoring ${itemsCount} items${suffix}"
    restoreItems oldVault newVault oldIds idMap "${itemsCount}"

    # Add a note (STEP 10)

    addNote "${backupFile}" ${itemsCount} ${foldersCount} ${attachmentsCount}

    # Process attachments if we have any (STEP 11)

    if (( ${attachmentsCount} > 0 )); then

        restartSpinner "${doneCheck}" "Uploading ${attachmentsCount} attachments"

        # Create attachments using the new ids

        local attachmentDir attachmentItemId attachmentsCount=0
        pushd "${attachmentsDirName}" > /dev/null || fail

        for attachmentDir in ./*; do

            pushd "${attachmentDir}" > /dev/null || fail
            local attachmentItemId="$(basename ${attachmentDir})"
            local mappedAttachmentItemId="${idMap[${attachmentItemId}]}"

            for file in ./*; do
                (( attachmentsCount++ ))
                bw create attachment --file "./${file}" --itemid "${mappedAttachmentItemId}" > /dev/null || fail
            done
            popd > /dev/null || fail
        done
    fi

    stopSpinner "${doneCheck}"

    echo
    echo "$(ansi bold_green Restore completed.)"
    echo
    echo "A note named '${restoreNoteName}' was added to your vault with details of this operation."
    echo
    echo "You may need to logout/login or sync to see the restored items."
}

addNote() {
    local source="${1}"
    local items=${2}
    local folders=${3}
    local attachments=${4}
    local i=$( [[ ${items} == 1 ]] && echo item || echo items)
    local f=$( [[ ${folders} == 1 ]] && echo folder || echo folders)
    local a=$( [[ ${items} == 1 ]] && echo attachment || echo attachments)
    local format='Restored on %s\n\n%d %s, %d %s, %d %s from %s\n'
    note="$(printf "${format}" "$(date)" ${items} ${i} ${folders} ${f} ${attachments} ${a} "${source}")"

    echo "${note}" >> "${logFile}"

    local temp=$(bw get template item) || fail
    local name="${restoreNoteName}"
    local item=$(echo ${temp} | jq -r --arg nm "${name}" --arg nt "${note}" '.type=2 | .secureNote.type=0 | .name=$nm | .notes=$nt')
    echo ${item} | bw encode | bw create item > /dev/null || fail
}

prefixNamesWithIndex() {
    local -n vaultRef=${1}
    local itemsCount=${2}
    local name newName
    local tempVault="${vaultRef}" # TODO don't need this indirection

    for ((i = 0; i < itemsCount; i++)); do
        name=$(echo "${tempVault}" | jq -r --argjson i ${i} '.items[$i].name')
        newName="<${i}> ${name}"
        tempVault=$(echo "${tempVault}" | jq --argjson i ${i} --arg name "${newName}" '.items[$i].name=$name')
    done
echo "${tempVault}" | jq > "${HOME}/index.json" # TODO REMOVE
    vaultRef="${tempVault}"
}

buildIdMap() {

    #  9. Use the index numbers from ${newVault} as an index to select a newId and combine it with oldIds into a map.

    local -n newVaultRef=${1}
    local -n oldIdsRef=${2}
    local -n idMapRef=${3}
    local itemsCount=${4}
    local oldId newId

    for (( i = 0; i < itemsCount; i++ )); do
        oldId=${oldIdsRef[${i}]}
        newItem=$(echo "${newVaultRef}" | jq -r --arg index ${i} '.items[] | select(.name | startswith("<" + ($index|tostring) + ">"))')
        newId=$(echo "${newItem}" | jq -r '.id')
        idMapRef["${oldId}"]="${newId}"
    done
}

log() {
    echo "${@}" >> "${logFile}"
}
restoreItems() {
    local -n oldVaultRef=${1}
    local -n newVaultRef=${2}
    local -n oldIdsRef=${3}
    local -n idMapRef=${4}
    local itemsCount=${5}
    local i oldId newId newItem indexedName name newItem cDate rDate dDate

    for (( i = 0; i < itemsCount; i++ )); do
        oldId=${oldIdsRef[${i}]}
        newId=${idMapRef[${oldId}]}
        oldItem=$(echo ${oldVaultRef} | jq -r --arg id "${oldId}" '.items[] | select(.id == $id)')

        newItem=$(bw get item "${newId}")

        indexedName=$(echo ${newItem} | jq -r '.name')
        name="${indexedName#\<[0-9]*\> }"

# See https://github.com/bitwarden/clients/issues/13429
#
#        cDate=$(echo ${oldItem} | jq -r '.creationDate')
#        rDate=$(echo ${oldItem} | jq -r '.revisionDate')
#        dDate=$(echo ${oldItem} | jq -r '.deletedDate')
#
#        newItem=$(echo "${newItem}" | jq -c --arg name "${name}" --arg c "${cDate}" --arg r "${rDate}" --arg d "${dDate}" \
#            '.name=$name | .creationDate=$c | .revisionDate=$r | .deletedDate=$d' )

        newItem=$(echo "${newItem}" | jq -c --arg name "${name}" '.name=$name' )
        echo "${newItem}" | bw encode | bw edit item "${newId}" > /dev/null 2>> "${logFile}"
    done
}

assertVaultEmpty() {
    local vault="$(bw export --raw --format json)"

    local orgVault="$(echo "${vault}" | jq '.collections != null' | grep true)"
    [[ ${orgVault} ]] && fail "Cannot restore to an Organization vault (yet)."

    local itemsCount=$(echo "${vault}" | jq '.items // 0 | length')
    (( itemsCount == 0 )) || failVaultNotEmpty

    local foldersCount=$(echo "${vault}" | jq '.folders // 0 | length')
    (( foldersCount == 0 )) || failVaultNotEmpty
}

failVaultNotEmpty() {
    warn "This vault must be empty before restoring to it."
    echo
    echo "If you are not $(ansi bold_italic sure) that you have a current backup, make another one or restore"
    echo "to a new account (with a Premium subscription if you have attachments)."
    echo
    echo "If you choose to empty the target vault:"
    echo
    echo "  1. In a browser, login at $(ansi blue ${vaultUrl})."
    echo "  2. In the left pane, under $(ansi bold Settings), click $(ansi bold My Account)."
    echo "  3. In the $(ansi bold_red Danger zone) section, click $(ansi bold_red Purge vault)."
    echo "  4. In the popup, enter you master password and click $(ansi bold_red Purge vault)."
    fail
}

logoutFromVault() {
    local arg=${1}
    if [[ ${arg} == force ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    elif [[ ${BW_SESSION} && ! ${VALT_USE_PARENT_SESSION} ]]; then
        if [[ ${arg} == verbose ]]; then
            echo
            echo "$(ansi bold_blue Logging out of vault)  "
            echo
            bw logout > /dev/null 2>&1
            echo "$(ansi bold_green Logged out.)"
        else
            bw logout > /dev/null 2>&1
        fi
        unset BW_SESSION
    fi
}

cleanup() {
    logoutFromVault
    if [[ ${generatedTempDir} ]]; then
        rm -rf "${generatedTempDir}" > /dev/null 2>&1 || warn "Failed to delete temp dir: ${generatedTempDir}"
    fi
}

# Load core library

source "${HOME}/.rayvn/boot.sh" 2>/dev/null || { echo 'rayvn not installed' && exit 0; }
require 'core/base'
require 'core/spinner'

# Define required executables (assertion in main to avoid delay with help).

declare -A requiredExecutables=(

    [bw_min]='2025.1.0'
    [bw_brew]=false
    [bw_install]='https://bitwarden.com/download/#downloads-command-line-interface'
    [bw_version]='versionExtract'

    [rage_min]='0.11.1'
    [rage_brew]=true
    [rage_brew_tap]='str4d.xyz/rage https://str4d.xyz/rage'
    [rage_install]='https://github.com/str4d/rage'
    [rage_version]='versionExtract'

    [jq_min]='1.7.1'
    [jq_brew]=true
    [jq_install]='https://jqlang.github.io/jq/download/'
    [jq_version]='versionExtractDash'
)

testIdMapping() {  # TODO REMOVE
    local oldIds=()
    local oldVault="$(cat ${HOME}/vault.json)"
    local newVault="$(cat ${HOME}/new-vault.json)"
    local newItemsCount=$(echo "${newVault}" | jq '.items // 0 | length')
    declare -A idMap=()
    mapfile -t oldIds < <(echo "${oldVault}" | jq -r '.items[].id')

    buildIdMap newVault oldIds idMap ${newItemsCount}

    itemOne="21b1fc8a-6d77-4a8d-a148-b283003c81a7"
    itemTwo="ef05e600-c1c6-4b2c-8769-b283003c9dea"
    note="restored-note-xxxx-xxxx-xxxxxxxxxxxx"

    itemOneNew="37786c11-8a4f-4d3d-98b5-b2830156503f"
    itemTwoNew="6ed2e2e8-043a-4ff9-9d22-b2830156503f"
    noteNew="92f9e3a9-f038-4e71-a747-b2830156503f"

    itemOneMap=${idMap[${itemOne}]}
    itemTwoMap=${idMap[${itemTwo}]}
    noteMap=${idMap[${note}]}

    ok="${_greenCheckMark}"
    expected="$(ansi bold_red EXPECTED:)"

    itemOneMapResult="$([[ ${itemOneMap} == "${itemOneNew}" ]] && echo "${ok}" || echo "${expected} ${itemOneNew}")"
    itemTwoMapResult="$([[ ${itemTwoMap} == "${itemTwoNew}" ]] && echo "${ok}" || echo "${expected} ${itemTwoNew}")"
    noteMapResult="$([[ ${noteMap} == "${noteNew}" ]] && echo "${ok}" || echo "${expected} ${noteNew}")"

    echo
    echo "Item One: ${itemOne} -> ${itemOneMap} ${itemOneMapResult}"
    echo "Item Two: ${itemTwo} -> ${itemTwoMap} ${itemTwoMapResult}"
    echo "    Note: ${note} -> ${noteMap} ${noteMapResult}"

    restoreItems oldVault newVault oldIds idMap ${newItemsCount}

    echo; echo '---- NEW VAULT ------------'; echo

    echo "${newVault}" | jq

}

main "${@}"
