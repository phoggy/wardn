#!/usr/bin/env bash
# shellcheck disable=SC2155

declare -grx BW_BACKUP_VERSION='bw-backup 0.1.0'

# TODO: what to do about account recovery code?

# shellcheck disable=SC2120
usage() {
    echo
    echo "$(ansi bold Create a backup of a Bitwarden vault or restore a vault from one, secured by an) $(ansi cyan Age) $(ansi bold public key pair.)"
    echo
    echo "Usage: $(ansi bold_blue ${scriptName}) [backup] (-r RECIPIENT | -R PATH)... [-b BACKUP_DIR]"
    echo "       $(ansi bold_blue ${scriptName}) restore BACKUP_FILE -i IDENTITY"
    echo
    echo "The Bitwarden CLI is used to access the vault. Login/unlock requires user input: credentials are never stored."
    echo "Using an API key simplifies login, requiring only master password input rather than full credentials. This is"
    echo "enabled by setting the BW_CLIENTID and BW_CLIENTSECRET environment variables, for details see"
    echo "$(ansi blue https://bitwarden.com/help/personal-api-key/)."
    echo
    echo "The Bitwarden CLI is used, and  and an API key and secret is required, both of which must be "
    echo
    echo "Backup files are encrypted with $(ansi cyan Age) public keys â€” see $(ansi blue ${rageProjectUrl}) for details on features"
    echo "and key creation. In the $(ansi cyan Age) system, a public key is called a 'recipient' and a private key is called an"
    echo "'identity'. Identities/private keys $(ansi bold_italic SHOULD) be protected by a strong password for this use case, and a copy"
    echo "of both the key and password should be stored offline in $(ansi italic at least) one secure location."
    echo
    echo "$(ansi bold_green Note) A temporary directory is required during both operations, and $(ansi italic unencrypted) vault data will be stored there."
    echo "These files will be deleted by this script; however, file recovery software may still be able to read them long"
    echo "afterward. Standard security practice is to use encrypted storage to avoid this risk, so by default you will be"
    echo "prompted to agree that the temp directory is secured. If your system uses whole disk encryption, or if the"
    echo "directory specified via -t is known to be encrypted (e.g. by VeraCrypt), this prompt can be suppressed by"
    echo "setting the BW_BACKUP_TEMP_DIRECTORY environment variable (see below)."
    echo
    echo "Options:"
    echo
    echo "    -t, --temp-dir PATH            Use the directory at PATH for temporary storage."
    echo "    -r, --recipient RECIPIENT      Encrypt to the specified RECIPIENT (public key). May be repeated."
    echo "    -R, --recipients-file PATH     Encrypt to the recipients (public keys) listed at PATH. May be repeated."
    echo "    -b, --backup-dir PATH          Use the directory at PATH to store the encrypted backup."
    echo "    -p, --prefix PREFIX            Set a prefix for the backup file name."
    echo "    -u, --url URL                  Set the URL for the Bitwarden server. Defaults to ${defaultServerUrl}"
    echo "    -i, --identity IDENTITY        Restore using the identity (private key) file at IDENTITY. May be repeated."
    echo "    -h, --help                     Display usage and exit."
    echo "    --version                      Display version and exit."
    echo
    echo "Environment Variables"
    echo
    echo "    BW_CLIENTID                    Set the Bitwarden API key."
    echo "    BW_CLIENTSECRET                Set the Bitwarden API key secret."
    echo "    BW_BACKUP_PREFIX               Set default backup name prefix."
    echo "    BW_BACKUP_RECIPIENT            Set default recipient. May be a path to a recipients file."
    echo "    BW_BACKUP_DIR                  Set the default backup directory."
    echo "    BW_BACKUP_SECURE_TEMP_DIR      Set the default secure temp directory. Use '@' to create a path via $(ansi italic mktemp)."
    echo "    BW_BACKUP_PASSWORD_VISIBILITY  Set the visibility of password entry characters: none, hide, show. Default: none"
    bye "${@}"
}

main() {
    assertExecutables requiredExecutables
    init "${@}"
    if ! useParentSession; then
        ensureLatestCLI
        loginToVault
    fi
    syncVault
    if [[ ${restoreFile} ]]; then
        restoreVault
    else
        backupVault
    fi
    logoutFromVault verbose
}

init() {
    [[ ${LANG} =~ .UTF-8 ]] || warn "The LANG env var should be a UTF-8 type, but is ${LANG}"

    readonly scriptName="$(basename "${0}")"
    readonly rageProjectUrl='https://github.com/str4d/rage'
    readonly defaultServerUrl="https://vault.bitwarden.com"
    readonly backupFileSuffix="tar.gz.age"
    readonly restoreNoteName="ðŸ”¥ Restored Vault ðŸ”¥"
    readonly vaultFileName="vault.json"
    readonly importVaultFileName="import-vault.json"
    readonly attachmentsDirName="attachments"
    declare -grx passwordVisibility="${VALT_BACKUP_PASSWORD_VISIBILITY:-none}"

    useRayvnPinEntry

    namePrefix="${VALT_BACKUP_PREFIX}"
    vaultUrl=
    identities=
    backupFile=
    restoreFile=
    suppliedTempDir="${VALT_BACKUP_SECURE_TEMP_DIR}"
    backupDir="${VALT_BACKUP_DIR}"
    recipients="${VALT_BACKUP_RECIPIENT}"

    [[ ${suppliedTempDir} && ${suppliedTempDir} != @ ]] && setDirVar suppliedTempDir "${suppliedTempDir}"
    [[ ${backupDir} ]] && setDirVar backupDir "${backupDir}"
    [[ ${recipients} && -f ${recipients} ]] && recipients="-R ${recipients}" || recipients="-r ${recipients}"

    while ((${#} > 0)); do
        case "${1}" in
        backup) unset restoreFile ;;
        restore) shift; setFileVar restoreFile "${1}" ;;
        -t | --temp-dir) shift; setDirVar suppliedTempDir "${1}" "secure temp dir path" ;;
        -r | --recipient) shift; appendVar recipients "-r ${1}" ;;
        -R | --recipients-file) shift; assertFile "${1}" "recipients file"; appendVar recipients "-R ${1}" ;;
        -i | --identity) shift; assertFile "${1}" "identities file"; appendVar identities "-i ${1}" ;;
        -b | --backup-dir) shift; setDirVar backupDir "${1}" "backup dir path" ;;
        -p | --prefix) shift; namePrefix="${1}" ;;
        -u | --url) shift; vaultUrl="${1}" ;;
        -h | --help) usage ;;
        -v | --version) version "${VALT_BACKUP_VERSION}" ;;
        *) fail "Unknown argument: ${1}" ;;
        esac
        shift
    done

    [[ ${vaultUrl} ]] || vaultUrl="${defaultServerUrl}"

    if [[ ! ${restoreFile} ]]; then

        # backup

        [[ ${recipients} ]] || fail "one or more recipients required"
        [[ ${namePrefix} ]] || namePrefix="${USER}"
        readonly backupName="${namePrefix}-backup-$(timeStamp)"

        if [[ ${backupDir} ]]; then
            backupFile="${backupDir}/${backupName}.${backupFileSuffix}"
        else
            backupFile="${backupName}.${backupFileSuffix}"
        fi
    else

        # restore

        [[ ${identities} ]] || fail "one or more identities required"
        readonly backupName="$(basename ${restoreFile} | cut -d'.' -f1-3)"
    fi

    addExitHandler cleanup

    initSecureTempDir
    readonly secureWorkDir="$(makeDir "${secureTempDir}" "${backupName}")"
    chmod 700 "${secureWorkDir}" || fail
    readonly vaultFile="${secureWorkDir}/vault.json"
    readonly attachmentsDir="$(makeDir ${secureWorkDir} attachments)"
}

initSecureTempDir() {
    local verifySecure
    if [[ ${suppliedTempDir} == '' || ${suppliedTempDir} == '@' ]]; then

        # Use the rayvn system temp dir which will be deleted by rayvn on exit

        secureTempDir="$(tempDirPath)"

    else

        # User supplied, so generate a temp dir within it. Remember the generated dir
        # to ensure we delete it on exit

        local randomDirName="$(basename "$(mktemp -d -u)")" || fail
        suppliedTempDir="${suppliedTempDir}"
        generatedTempDir="$(makeDir ${suppliedTempDir} ${randomDirName})"
        secureTempDir=${generatedTempDir}
        verifySecure=true
    fi
    [[ -d ${secureTempDir} ]] || fail "Secure temp directory ${secureTempDir} not found!"
    cd "${secureTempDir}" || fail
    [[ ${verifySecure} ]] && verifySecureTempDir
}

verifySecureTempDir() {
    local source
    local reply
    [[ ${generatedTempDir} ]] && source="supplied '${suppliedTempDir}' as root of" || source="system"
    echo
    echo "$(ansi bold Verify configuration)"
    echo
    echo "Using ${source} temp directory: $(ansi blue ${secureTempDir})"
    echo
    read -t 30 -p "This directory SHOULD be encrypted to avoid leaking sensitive data. $(ansi bold_green Proceed?) [yes/no]: " reply
    if [[ ${reply,,} != 'yes' ]]; then
        echo
        fail "See help for more about this issue: ${scriptName} --help"
    fi
}

ensureLatestCLI() {
    echo
    echo "$(ansi bold_blue Checking Bitwarden CLI version)"
    echo
    local update="$(bw update 2>&1)"
    if [[ ${update} =~ "new version" ]]; then
        printRed "The Bitwarden CLI at $(which bw) is out of date."
        echo
        echo "${update}"
        fail
    fi
    echo "$(ansi bold_green "$(which bw)") is the latest version ($(bw --version))"
}

useParentSession() {
    if [[ ${VALT_USE_PARENT_SESSION} && ${BW_SESSION} ]]; then
        if [[ $(sessionStatus) == unlocked ]]; then
            echo
            echo "$(ansi bold_italic Using parent session)"
            return 0
        fi
    fi
    return 1
}

sessionStatus() {
    bw status | jq -r .status
}

loginToVault() {
    echo
    echo "$(ansi bold_blue Logging in to vault)"
    echo
    startSpinner

    logoutFromVault force # just in case there is an active session
    declare -gx BW_SESSION

    bw config server "${vaultUrl}" > /dev/null

    if [[ ${BW_CLIENTID} ]]; then

        # Use api key

        bw login --apikey > /dev/null || fail "login failed"
        if [[ ${VALT_BACKUP_DEV_PWD} ]]; then
            BW_SESSION="$(bw unlock --raw --passwordenv VALT_BACKUP_DEV_PWD)"
        else
            for retryIndex in {1..3}; do
                echo
                BW_SESSION="$(bw unlock --raw)" && break
            done
        fi
        stopSpinner
    else
        stopSpinner
        if [[ ${VALT_BACKUP_DEV_PWD} ]]; then
            BW_SESSION="$(bw login --raw --passwordenv VALT_BACKUP_DEV_PWD)"
        else
            for retryIndex in {1..3}; do
                echo
                BW_SESSION="$(bw login --raw)" && break
            done
        fi
        echo
    fi

    [[ ${BW_SESSION} ]] || fail "login failed"

    echo "$(ansi bold_green Logged in.)"
}

syncVault() {
    echo
    echo "$(ansi bold_blue Syncing vault)"
    echo
    bw sync > /dev/null || fail
    echo "Vault is current."
}

backupVault() {
    local items item
    local attachmentItemIds attachmentItemId
    local attachments attachment
    local attachDir
    echo
    echo "$(ansi bold_blue Backing up vault)  "
    echo
    startSpinner

    bw export --raw --format json > "${vaultFile}" || failSpin

    items="$(bw list items)"

    attachmentItemIds="$(echo ${items} | jq -r ".[] | select(.attachments).id")"

    for attachmentItemId in ${attachmentItemIds}; do
        item="$(echo "${items}" | jq -r ".[] | select(.id == \"${attachmentItemId}\")")"
        attachments="$(echo "${item}" | jq -r ".attachments")"
        length="$(echo "${attachments}" | jq -r ". | length")"

        for ((retryIndex = 0; retryIndex < ${length}; retryIndex++)); do
            attachDir="$(makeDir ${attachmentsDir} ${attachmentItemId})"

            attachment="$(echo "${attachments}" | jq ".[${retryIndex}]")"
            attachmentId="$(echo "${attachment}" | jq -r ".id")"
            fileName="$(echo "${attachment}" | jq -r ".fileName")"

            # get attachment

            bw get attachment "${attachmentId}" --itemid "${attachmentItemId}" \
                --output "${attachDir}/${fileName}" >/dev/null 2>&1 || failSpin
        done
    done

    # TODO can recipients be encrypted?
    tar cz "${backupName}" | rage ${recipients} > ${backupFile} || failSpin
    local size="$(du -h "${backupFile}" | cut -d' ' -f2 | cut -d $'\t' -f1)"

    stopSpinner
    echo "$(ansi bold_green Vault backed up to) ${backupFile} $(ansi bold_green size): $(ansi bold ${size})"
}

restoreVault() {
    local backupFile="${restoreFile}"
    local backupFileName="$(basename ${backupFile})"
    local backupDate="$(basename ${backupFileName#*backup-*-} .${backupFileSuffix})"
    local doneCheck=". ${_greenCheckMark}"

    echo
    echo "$(ansi bold_blue Checking vault)"
    echo
    assertVaultEmpty
    echo "Vault is empty."
    echo
    echo "$(ansi bold_blue Restoring vault) from $(ansi blue ${backupFileName})"
    echo

    # Extract contents of decrypted backup file to secureWorkDir

    cd "${secureWorkDir}" || fail
    local tarFile="backup.tar"
    rage -d ${identities} "${backupFile}" -o "${tarFile}" 2> >(redStream) || fail
    echo

    startSpinner "Preparing import" # don't start until here, since the above will likely prompt for a password

    tar -xf "${tarFile}" --strip-components=1 || fail
    rm "${tarFile}" || fail

    # Get vault and grab some stats from it

    local vault="$(cat "${vaultFileName}")"
    local itemsCount=$(echo "${vault}" | jq '.items // 0 | length')
    local foldersCount=$(echo "${vault}" | jq '.folders // 0 | length')
    local attachmentsCount="$(find attachments -type f | wc -l | awk '{print $1}')"
    local attachmentsCountMsg="$( (( ${attachmentsCount} > 0 )) && echo ${attachmentsCount} || echo "no")"

    # Add a note describing the backup

    local note="HERE IS MY NOTE\nline 2\nline3"  # TODO
    local template=$(bw get template item | jq '.type = 2 | .secureNote.type = 0')
    local item=$(echo "${template}" | jq -c --arg name "${restoreNoteName}" --arg note "${note}" '.type=2 | .favorite=true | .name=$name | .notes=$note')
    echo "${vault}" | jq -c --argjson item "$item" '.items += [$item]' > "${importVaultFileName}"

    # Import updated vault

    restartSpinner "${doneCheck}" "Performing import"
    bw import bitwardenjson "${secureWorkDir}/${importVaultFileName}" > /dev/null || fail

    # Process attachments if we have any

    if (( ${attachmentsCount} > 0 )); then

        restartSpinner "${doneCheck}" "Processing ${attachmentsCount} attachments"

        # Map the old item ids to the new ones

        declare -A idMap=()
        local newVault="$(bw export --format json --raw)" || fail
        mapIds vault newVault idMap items

        # Create attachments using the new ids

        local attachmentDir attachmentItemId attachmentsCount=0
        pushd "${attachmentsDirName}" > /dev/null || fail

        for attachmentDir in ./*; do

            pushd "${attachmentDir}" > /dev/null || fail
            local attachmentItemId="$(basename ${attachmentDir})"
            local mappedAttachmentItemId="${idMap[${attachmentItemId}]}"

            for file in ./*; do
                (( attachmentsCount++ ))
                bw create attachment --file "./${file}" --itemid "${mappedAttachmentItemId}" > /dev/null || fail
            done
            popd > /dev/null || fail
        done
    fi

    stopSpinner "${doneCheck}"

    echo
    echo "$(ansi bold_green Restore completed.)"
    echo
    echo "A note named '${restoreNoteName}' was added to your vault with details of this operation."
}

mapIds() {
    local -n old=${1}
    local -n new=${2}
    local -n map=${3}
    local type=${4};
    local oldIds=()
    local newIds=()

    mapfile -t oldIds < <(echo "${old}" | jq -r ".\"${type}\" | .[] | .id");
    mapfile -t newIds < <(echo "${new}" | jq -r ".\"${type}\" | .[] | .id");

    (( ${#oldIds[@]} == ${#oldIds[@]} )) || fail "old and new id arrays are different lengths!"

    for i in "${!oldIds[@]}"; do
        map["${oldIds[${i}]}"]="${newIds[${i}]}"
    done
}

assertVaultEmpty() {
    local vault="$(bw export --raw --format json)"

    local orgVault="$(echo "${vault}" | jq '.collections != null' | grep true)"
    [[ ${orgVault} ]] && fail "Cannot restore to an Organization vault (yet)."

    local itemsCount=$(echo "${vault}" | jq '.items // 0 | length')
    (( itemsCount == 0 )) || failVaultNotEmpty

    local foldersCount=$(echo "${vault}" | jq '.folders // 0 | length')
    (( foldersCount == 0 )) || failVaultNotEmpty
}

failVaultNotEmpty() {
    warn "This vault must be empty before restoring to it."
    echo
    echo "If you are $(ansi bold not) $(ansi bold_italic sure) that you have a current backup, make another one!"
    echo "When ready, do the following to empty your vault:"
    echo
    echo "  1. In a browser, login at $(ansi blue ${vaultUrl})."
    echo "  2. Under $(ansi bold Settings) (in the left pane), click $(ansi bold My Account)."
    echo "  3. In the $(ansi bold_red Danger zone) section, click $(ansi bold_red Purge vault)."
    echo "  4. In the popup, enter you master password and click $(ansi bold_red Purge vault)."
    fail
}

logoutFromVault() {
    local arg=${1}
    if [[ ${arg} == force ]]; then
        bw logout > /dev/null 2>&1
        unset BW_SESSION
    elif [[ ${BW_SESSION} && ! ${VALT_USE_PARENT_SESSION} ]]; then
        if [[ ${arg} == verbose ]]; then
            echo
            echo "$(ansi bold_blue Logging out of vault)  "
            echo
            bw logout > /dev/null 2>&1
            echo "$(ansi bold_green Logged out.)"
        else
            bw logout > /dev/null 2>&1
        fi
        unset BW_SESSION
    fi
}

cleanup() {
    logoutFromVault
    if [[ ${generatedTempDir} ]]; then
        rm -rf "${generatedTempDir}" > /dev/null 2>&1 || warn "Failed to delete temp dir: ${generatedTempDir}"
    fi
}

# Load core library

source "${HOME}/.rayvn/boot.sh" 2>/dev/null || { echo 'rayvn not installed' && exit 0; }
require 'core/base'
require 'core/spinner'

# Define required executables (assertion in main to avoid delay with help).

declare -A requiredExecutables=(

    [bw_min]='2025.1.0'
    [bw_brew]=false
    [bw_install]='https://bitwarden.com/download/#downloads-command-line-interface'
    [bw_version]='versionExtract'

    [rage_min]='0.11.1'
    [rage_brew]=true
    [rage_brew_tap]='str4d.xyz/rage https://str4d.xyz/rage'
    [rage_install]='https://github.com/str4d/rage'
    [rage_version]='versionExtract'

    [jq_min]='1.7.1'
    [jq_brew]=true
    [jq_install]='https://jqlang.github.io/jq/download/'
    [jq_version]='versionExtractDash'
)

main "${@}"
